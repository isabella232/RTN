DATABASE ???;

CREATE MULTISET TABLE ???.DIM_DASH_VIZ_METRIC_XREF ,FALLBACK ,
    NO BEFORE JOURNAL,
    NO AFTER JOURNAL,
    CHECKSUM = DEFAULT,
    DEFAULT MERGEBLOCKRATIO,
    MAP = TD_MAP1
    (
    CORP_ID SMALLINT NOT NULL,
    CORP_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    CORP_FUNCTION VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    DASHBOARD_VERSION VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    SEMANTIC_VIEW_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    GEO_GRANULARITY VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL,
    DATE_GRANULARITY VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL,
    METRIC_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL,
    METRIC_DISPLAY_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    METRIC_DISPLAY_SHORT_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    METRIC_UOM VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    DASH_VIZ_DISPLAY_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    METRIC_VAL_IND_SEL VARCHAR(1) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL,
    DOMAIN_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL,
    SUBDOMAIN_1_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    SUBDOMAIN_2_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    SUBDOMAIN_3_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
    DATA_SOURCE_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL)
    PRIMARY INDEX ( CORP_ID ,CORP_FUNCTION ,METRIC_NAME ,DOMAIN_NAME ,
    DATA_SOURCE_NAME );
	
	
CREATE SET TABLE ???.DIM_GEO_LOCATION_T ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      UID INTEGER,
      GEO_GRANULARITY VARCHAR(7) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Country_code VARCHAR(2) CHARACTER SET LATIN NOT CASESPECIFIC,
      iso3 VARCHAR(3) CHARACTER SET LATIN NOT CASESPECIFIC,
      code3 INTEGER,
      FIPS INTEGER,
      County VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      County_long VARCHAR(135) CHARACTER SET LATIN NOT CASESPECIFIC,
      STATE_NAME VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      STATE_CODE CHAR(2) CHARACTER SET LATIN NOT CASESPECIFIC,
      COUNTRY_NAME VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      Lat FLOAT,
      Lon FLOAT,
      Combined_Key VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      Population INTEGER)
PRIMARY INDEX ( UID )
INDEX IDX_GEO_LOC_1 ( County )
INDEX IDX_GEO_LOC_2 ( Country_code );


CREATE MULTISET TABLE ???.DIM_People_location ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      CLient_nbr INTEGER,
      Client_name VARCHAR(65) CHARACTER SET LATIN NOT CASESPECIFIC,
      Site_Id VARCHAR(15) CHARACTER SET LATIN NOT CASESPECIFIC,
      Site_Type VARCHAR(15) CHARACTER SET LATIN NOT CASESPECIFIC,
      Address VARCHAR(65) CHARACTER SET LATIN NOT CASESPECIFIC,
      City VARCHAR(25) CHARACTER SET LATIN NOT CASESPECIFIC,
      State VARCHAR(25) CHARACTER SET LATIN NOT CASESPECIFIC,
      Zipcode VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC,
      Region VARCHAR(25) CHARACTER SET LATIN NOT CASESPECIFIC,
      Country_cd VARCHAR(4) CHARACTER SET LATIN NOT CASESPECIFIC,
      Nbr_at_location SMALLINT,
      People_type VARCHAR(25) CHARACTER SET LATIN NOT CASESPECIFIC)
PRIMARY INDEX ( Site_Id )
INDEX IDX_PEOPLE_LOCATION_1 ( Zipcode );


CREATE MULTISET TABLE ???.DIM_Site_addresses ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      CLient_nbr INTEGER,
      Client_name VARCHAR(65) CHARACTER SET LATIN NOT CASESPECIFIC,
      Site_Id VARCHAR(15) CHARACTER SET LATIN NOT CASESPECIFIC,
      Site_Type VARCHAR(15) CHARACTER SET LATIN NOT CASESPECIFIC,
      Address VARCHAR(65) CHARACTER SET LATIN NOT CASESPECIFIC,
      City VARCHAR(25) CHARACTER SET LATIN NOT CASESPECIFIC,
      State VARCHAR(25) CHARACTER SET LATIN NOT CASESPECIFIC,
      Zipcode VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC,
      Region VARCHAR(25) CHARACTER SET LATIN NOT CASESPECIFIC,
      Country_cd VARCHAR(4) CHARACTER SET LATIN NOT CASESPECIFIC,
      FTE_HC_at_Location SMALLINT,
      Contingent_HC_at_Location SMALLINT,
      Number_of_Desks VARCHAR(14) CHARACTER SET LATIN NOT CASESPECIFIC,
      Average_Attendance VARCHAR(14) CHARACTER SET LATIN NOT CASESPECIFIC,
      Security_Type VARCHAR(15) CHARACTER SET LATIN NOT CASESPECIFIC)
PRIMARY INDEX ( Site_Id )
INDEX IDX_SITE_ADDRESSES_1 ( Zipcode );


CREATE MULTISET TABLE ???.DIM_ZIPCODE_COUNTY_MSA_LKUP,FALLBACK ,
    NO BEFORE JOURNAL,
    NO AFTER JOURNAL,
    CHECKSUM = DEFAULT,
    DEFAULT MERGEBLOCKRATIO,
    MAP = TD_MAP1
    (
	 ZIPCODE VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC,
	 STATE_NAME VARCHAR(100) CHARACTER SET LATIN NOT CASESPECIFIC,
	 COUNTY_FIPS VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC,
	 COUNTY_NAME VARCHAR(100) CHARACTER SET UNICODE NOT CASESPECIFIC,
	 MSA_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC
	)
	UNIQUE PRIMARY INDEX UPI_ZIP_LKP1 (ZIPCODE)
    INDEX SI_ZIP_LKP1 (COUNTY_NAME, STATE_NAME);	


CREATE MULTISET TABLE ???.DIM_ZIP_COUNTY_MSA_MAP_RAW, FALLBACK ,
    NO BEFORE JOURNAL,
    NO AFTER JOURNAL,
    CHECKSUM = DEFAULT,
    DEFAULT MERGEBLOCKRATIO,
    MAP = TD_MAP1
    (	
     ZIPCODE VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL,
     COUNTY_FIPS VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC,
     COUNTY_RES_RATIO DECIMAL(20,10),
     COUNTY_BUS_RATIO DECIMAL(20,10),
     COUNTY_OTH_RATIO DECIMAL(20,10),
     COUNTY_TOT_RATIO DECIMAL(20,10),
     TOP_ZIP_FLAG SMALLINT,
     SPLIT_COUNTY_CNT SMALLINT,
     TOP_COUNTY_FLAG SMALLINT,
     COUNTY_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC,
     CBSA_CODE VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC,
     CBSA_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC,
     MSA_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC,
     STATE_NAME VARCHAR(255) CHARACTER SET LATIN NOT CASESPECIFIC
    )
    PRIMARY INDEX UPI_ZIP_MAPZ (ZIPCODE);


CREATE MULTISET TABLE ???.ETL_Indicator_Proj_Audit ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      Process_Name VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Table_Type VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      TableName VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Records_Processed BIGINT,
      Process_Dttm TIMESTAMP(6))
NO PRIMARY INDEX ;


CREATE SET TABLE ???.ETL_Proc_Error_Logs ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      Error_log_id INTEGER GENERATED ALWAYS AS IDENTITY
           (START WITH 1 
            INCREMENT BY 1 
            MINVALUE 0 
            MAXVALUE 2147483647 
            CYCLE),
      Sql_Code INTEGER,
      Logged_Time TIMESTAMP(0),
      Sql_State VARCHAR(20) CHARACTER SET LATIN NOT CASESPECIFIC,
      Error_Text VARCHAR(300) CHARACTER SET LATIN NOT CASESPECIFIC FORMAT 'X(50)',
      Procedure_Name VARCHAR(100) CHARACTER SET LATIN NOT CASESPECIFIC)
PRIMARY INDEX ( Error_log_id );


CREATE MULTISET TABLE ???.FACT_COVID19_DATAHUB ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      DATE_KEY DATE FORMAT 'YYYY/MM/DD',
      GEO_KEY BIGINT,
      TESTCNT BIGINT,
      CONFIRMED_CNT BIGINT,
      RECOVERED_CNT BIGINT,
      DEATHS_CNT BIGINT,
      HOSPITALIZED_CNT BIGINT,
      ON_VENTILATOR_CNT BIGINT,
      IN_ICU_CNT BIGINT,
      SEVERE_CASE_CNT BIGINT,
      POPULATION FLOAT,
      SCHOOL_CLOSING BIGINT,
      WORKPLACE_CLOSING BIGINT,
      CANCEL_EVENTS BIGINT,
      GATHERINGS_RESTRICTIONS BIGINT,
      TRANSPORT_CLOSING BIGINT,
      STAY_HOME_RESTRICTIONS BIGINT,
      INTERNAL_MOVEMENT_RESTRICTIONS BIGINT,
      INTERNATIONAL_MOVEMENT_RESTRICTIONS BIGINT,
      INFORMATION_CAMPAIGNS BIGINT,
      TESTING_POLICY BIGINT,
      CONTACT_TRACING BIGINT,
      STRINGENCY_INDEX FLOAT,
      KEY_STR VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      KEY_NUMERIC FLOAT,
      KEY_GOOGLE_MOBILITY VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      KEY_APPLE_MOBILITY FLOAT,
      KEY_ALPHA_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      REC_INS_TS TIMESTAMP(6))
PRIMARY INDEX STG_COVID19_DATAHUB_PI ( DATE_KEY ,GEO_KEY )
PARTITION BY RANGE_N(DATE_KEY  BETWEEN DATE '1900-01-01' AND DATE '2030-12-31' EACH INTERVAL '1' DAY );


CREATE MULTISET TABLE ???.FACT_COVID19_DATAHUB_STATE ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      DATE_KEY DATE FORMAT 'YYYY/MM/DD',
      GEO_KEY BIGINT,
      TESTED_CNT BIGINT,
      CONFIRMED_CNT BIGINT,
      RECOVERED_CNT BIGINT,
      DEATH_CNT BIGINT,
      HOSPITALIZED_CNT BIGINT,
      ON_VENTILATOR_CNT BIGINT,
      IN_ICU_CNT BIGINT,
      SEVERE_CASE_CNT BIGINT,
      POPULATION FLOAT,
      SCHOOL_CLOSING BIGINT,
      WORKPLACE_CLOSING BIGINT,
      CANCEL_EVENTS BIGINT,
      GATHERINGS_RESTRICTIONS BIGINT,
      TRANSPORT_CLOSING BIGINT,
      STAY_HOME_RESTRICTIONS BIGINT,
      INTERNAL_MOVEMENT_RESTRICTIONS BIGINT,
      INTERNATIONAL_MOVEMENT_RESTRICTIONS BIGINT,
      INFORMATION_CAMPAIGNS BIGINT,
      TESTING_POLICY BIGINT,
      CONTACT_TRACING BIGINT,
      STRINGENCY_INDEX FLOAT,
      KEY_STR VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      KEY_NUMERIC FLOAT,
      KEY_GOOGLE_MOBILITY VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      KEY_APPLE_MOBILITY VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      KEY_ALPHA_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      REC_INS_TS TIMESTAMP(6))
PRIMARY INDEX STG_COVID19_DATAHUB_PI ( DATE_KEY ,GEO_KEY )
PARTITION BY RANGE_N(DATE_KEY  BETWEEN DATE '1900-01-01' AND DATE '2030-12-31' EACH INTERVAL '1' DAY );


CREATE MULTISET TABLE ???.FACT_Covid_Model_Data ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      MODEL_KEY INTEGER,
      DATE_KEY DATE FORMAT 'YYYY/MM/DD',
      DATE_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      GEO_KEY INTEGER NOT NULL,
      GEO_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      MODELED_DATE DATE FORMAT 'YYYY/MM/DD' NOT NULL,
      MODEL_VERSION INTEGER,
      location_name VARCHAR(32) CHARACTER SET LATIN NOT CASESPECIFIC,
      allbed_mean FLOAT,
      allbed_lower FLOAT,
      allbed_upper FLOAT,
      ICUbed_mean FLOAT,
      ICUbed_lower FLOAT,
      ICUbed_upper FLOAT,
      InvVen_mean FLOAT,
      InvVen_lower FLOAT,
      InvVen_upper FLOAT,
      deaths_mean FLOAT,
      deaths_lower FLOAT,
      deaths_upper FLOAT,
      admis_mean FLOAT,
      admis_lower FLOAT,
      admis_upper FLOAT,
      newICU_mean FLOAT,
      newICU_lower FLOAT,
      newICU_upper FLOAT,
      totdea_mean FLOAT,
      totdea_lower FLOAT,
      totdea_upper FLOAT,
      bedover_mean FLOAT,
      bedover_lower FLOAT,
      bedover_upper FLOAT,
      icuover_mean FLOAT,
      icuover_lower FLOAT,
      icuover_upper FLOAT,
      deaths_mean_smoothed FLOAT,
      deaths_lower_smoothed FLOAT,
      deaths_upper_smoothed FLOAT,
      totdea_mean_smoothed FLOAT,
      totdea_lower_smoothed FLOAT,
      totdea_upper_smoothed FLOAT,
      mobility_data_type VARCHAR(9) CHARACTER SET LATIN NOT CASESPECIFIC,
      mobility_composite FLOAT,
      total_tests_data_type VARCHAR(9) CHARACTER SET LATIN NOT CASESPECIFIC,
      total_tests FLOAT,
      confirmed_infections FLOAT,
      est_infections_mean FLOAT,
      est_infections_lower FLOAT,
      est_infections_upper FLOAT,
      REC_INS_TS TIMESTAMP(0),
      REC_UPD_TS TIMESTAMP(0),
	  Path_Update_Val VARCHAR(30) CHARACTER SET LATIN NOT CASESPECIFIC
      )
PRIMARY INDEX ( MODEL_KEY )
PARTITION BY RANGE_N(DATE_KEY  BETWEEN DATE '1900-01-01' AND DATE '2030-12-31' EACH INTERVAL '1' MONTH )
INDEX fidcmd_geo_index_1 ( GEO_KEY );


CREATE MULTISET TABLE ???.FACT_COVID_MODEL_DATA_SUM ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      DATE_KEY DATE FORMAT 'YYYY/MM/DD',
      DATE_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      GEO_KEY INTEGER NOT NULL,
      GEO_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      PEAK_BED_DAY_MEAN VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      PEAK_BED_DAY_LOWER VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      PEAK_BED_DAY_UPPER VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      PEAK_ICU_BED_DAY_MEAN VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      PEAK_ICU_BED_DAY_LOWER VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      PEAK_ICU_BED_DAY_UPPER VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      PEAK_VENT_DAY_MEAN VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      PEAK_VENT_DAY_LOWER VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      PEAK_VENT_DAY_UPPER VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      ALL_BED_CAPACITY FLOAT,
      ICU_BED_CAPACITY FLOAT,
      ALL_BED_USAGE FLOAT,
      ICU_BED_USAGE FLOAT,
      AVAILABLE_ALL_NBR FLOAT,
      AVAILABLE_ICU_NBR FLOAT,
      TRAVEL_LIMIT_START_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      TRAVEL_LIMIT_END_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      STAY_HOME_START_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      STAY_HOME_END_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      EDUCATIONAL_FAC_START_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      EDUCATIONAL_FAC_END_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      ANY_GATHERING_RESTRICT_START_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      ANY_GATHERING_RESTRICT_END_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      ANY_BUSINESS_START_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      ANY_BUSINESS_END_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      ALL_NON_ESS_BUSINESS_START_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      ALL_NON_ESS_BUSINESS_END_DATE VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      REC_INS_TS TIMESTAMP(0),
      REC_UPD_TS TIMESTAMP(0))
PRIMARY INDEX ( DATE_KEY ,GEO_KEY );


CREATE MULTISET TABLE ???.FACT_Covid_Model_Data_UNPIVOT ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      MODEL_KEY INTEGER,
      DATE_KEY DATE FORMAT 'YYYY/MM/DD',
      DATE_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      GEO_KEY INTEGER NOT NULL,
      GEO_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      MODELED_DATE DATE FORMAT 'YYYY/MM/DD' NOT NULL,
      MODEL_VERSION INTEGER,
      location_name VARCHAR(32) CHARACTER SET LATIN NOT CASESPECIFIC,
      mobility_data_type VARCHAR(9) CHARACTER SET LATIN NOT CASESPECIFIC,
      total_tests_data_type VARCHAR(9) CHARACTER SET LATIN NOT CASESPECIFIC,
      metric_name VARCHAR(32) CHARACTER SET LATIN NOT CASESPECIFIC,
      Metric_value FLOAT,
      REC_INS_TS TIMESTAMP(0),
      REC_UPD_TS TIMESTAMP(0))
PRIMARY INDEX ( MODEL_KEY );


CREATE MULTISET TABLE ???.FACT_INDICATOR_DASHBOARD_T2_P ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      INDICATOR_KEY INTEGER,
      DATE_KEY DATE FORMAT 'YYYY/MM/DD' NOT NULL,
      DATE_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      GEO_KEY INTEGER NOT NULL,
      GEO_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      DOMAIN_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      SUBDOMAIN_1_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      SUBDOMAIN_2_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      SUBDOMAIN_3_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      METRIC_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      METRIC_VALUE DECIMAL(32,6),
      METRIC_INDEX DECIMAL(32,6),
      DATA_SOURCE_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC,
      DATA_SOURCE_DESC VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC,
      REC_INS_TS TIMESTAMP(0),
      REC_UPD_TS TIMESTAMP(0))
PRIMARY INDEX ( INDICATOR_KEY )
PARTITION BY RANGE_N(DATE_KEY  BETWEEN DATE '1900-01-01' AND DATE '2030-12-31' EACH INTERVAL '1' MONTH )
INDEX fid_geo_index_1 ( GEO_KEY )
INDEX FID_DS_IDX_1 ( DATA_SOURCE_NAME );



CREATE MULTISET TABLE ???.F_IND_DASH_GOOGLE_TRENDS ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      DATE_KEY DATE FORMAT 'YYYY-MM-DD' NOT NULL,
      TREND_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      GEO_KEY INTEGER NOT NULL,
      GEO_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
      METRIC_INDEX DECIMAL(32,6),
      DATA_SOURCE_NAME VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC,
      DATA_SOURCE_DESC VARCHAR(255) CHARACTER SET UNICODE NOT CASESPECIFIC,
      SNAPSHOT_DATE DATE FORMAT 'YYYY-MM-DD' DEFAULT DATE ,
      REC_INS_TS TIMESTAMP(0) DEFAULT CURRENT_TIMESTAMP(0),
      REC_UPD_TS TIMESTAMP(0) DEFAULT CURRENT_TIMESTAMP(0))
PRIMARY INDEX ( DATE_KEY ,GEO_KEY ,SNAPSHOT_DATE )
PARTITION BY ( RANGE_N(SNAPSHOT_DATE  BETWEEN DATE '2020-01-01' AND DATE '2025-12-31' EACH INTERVAL '1' DAY ),
RANGE_N(DATE_KEY  BETWEEN DATE '2020-01-01' AND DATE '2025-12-31' EACH INTERVAL '1' DAY ) );


CREATE MULTISET TABLE ???.F_IND_DASH_NYT_COVID19_COUNTY_7MAVG ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      GEO_KEY INTEGER,
      GEO_GRANULARITY VARCHAR(10) CHARACTER SET UNICODE UPPERCASE NOT CASESPECIFIC,
      COUNTY VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      STATE_CODE CHAR(2) CHARACTER SET LATIN NOT CASESPECIFIC,
      STATE_NAME VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      COUNTRY_NAME VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      POPULATION INTEGER,
      DATE_KEY DATE FORMAT 'YYYY/MM/DD',
      CASES_TODATE DECIMAL(38,6),
      NEW_CASES DECIMAL(38,6),
      DEATHS_TODATE DECIMAL(38,6),
      NEW_DEATHS DECIMAL(38,6),
      COUNTY_POP_RNK INTEGER,
      CASES_7MAVG DECIMAL(38,5),
      DEATHS_7MAVG DECIMAL(38,5))
UNIQUE PRIMARY INDEX ( GEO_KEY ,DATE_KEY )
PARTITION BY RANGE_N(DATE_KEY  BETWEEN DATE '2019-06-01' AND DATE '2030-12-31' EACH INTERVAL '1' DAY );


CREATE MULTISET TABLE ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      SNAPSHOT_DATE DATE FORMAT 'YYYY-MM-DD' NOT NULL,
      SNAPSHOT_WEEK VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC,
      CURR_PREV_FLAG VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC,
      CAL_DAY_OF_WEEK SMALLINT,
      GEO_KEY INTEGER NOT NULL,
      GEO_GRANULARITY VARCHAR(10) CHARACTER SET LATIN NOT CASESPECIFIC,
      COUNTY VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      STATE_CODE CHAR(2) CHARACTER SET LATIN NOT CASESPECIFIC,
      STATE_NAME VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      COUNTRY_NAME VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC,
      COUNTY_POPULATION INTEGER,
      DATE_KEY DATE FORMAT 'YYYY-MM-DD' NOT NULL,
      CASES_TODATE DECIMAL(38,3),
      NEW_CASES DECIMAL(38,3),
      DEATHS_TODATE DECIMAL(38,3),
      NEW_DEATHS DECIMAL(38,3),
      COUNTY_POP_RNK INTEGER,
      CASES_TODATE_7MAVG DECIMAL(38,3),
      NEW_CASES_7MAVG DECIMAL(38,3),
      DEATHS_TODATE_7MAVG DECIMAL(38,3),
      NEW_DEATHS_7MAVG DECIMAL(38,3))
UNIQUE PRIMARY INDEX ( SNAPSHOT_DATE ,GEO_KEY ,DATE_KEY )
PARTITION BY RANGE_N(DATE_KEY  BETWEEN DATE '2019-06-01' AND DATE '2030-12-31' EACH INTERVAL '1' DAY );



CREATE SET TABLE ???.gm_step1 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      date_key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      country_region_code VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      country_region VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      sub_region_1 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      sub_region_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      METRIC_INDEX VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      METRIC_NAME VARCHAR(1000) CHARACTER SET UNICODE NOT CASESPECIFIC,
      geo_granularity VARCHAR(7) CHARACTER SET UNICODE NOT CASESPECIFIC)
PRIMARY INDEX ( country_region_code ,sub_region_1 ,sub_region_2 ,
geo_granularity );


CREATE SET TABLE ???.gm_step2 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      date_key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      date_granularity VARCHAR(3) CHARACTER SET UNICODE NOT CASESPECIFIC,
      geo_granularity VARCHAR(7) CHARACTER SET UNICODE NOT CASESPECIFIC,
      geo_key INTEGER,
      DOMAIN_NAME VARCHAR(8) CHARACTER SET UNICODE NOT CASESPECIFIC,
      SUBDOMAIN_1_NAME VARCHAR(15) CHARACTER SET UNICODE NOT CASESPECIFIC,
      SUBDOMAIN_2_NAME VARCHAR(1) CHARACTER SET UNICODE NOT CASESPECIFIC,
      SUBDOMAIN_3_NAME VARCHAR(1) CHARACTER SET UNICODE NOT CASESPECIFIC,
      METRIC_NAME VARCHAR(1030) CHARACTER SET UNICODE NOT CASESPECIFIC,
      METRIC_VALUE BYTEINT,
      METRIC_INDEX DECIMAL(32,6),
      DATA_SOURCE_NAME VARCHAR(22) CHARACTER SET UNICODE NOT CASESPECIFIC,
      DATA_SOURCE_DESC VARCHAR(22) CHARACTER SET UNICODE NOT CASESPECIFIC,
      REC_INS_TS TIMESTAMP(0) WITH TIME ZONE,
      REC_UPD_TS TIMESTAMP(0) WITH TIME ZONE)
PRIMARY INDEX ( date_key ,geo_granularity ,DOMAIN_NAME ,SUBDOMAIN_1_NAME ,
SUBDOMAIN_2_NAME ,SUBDOMAIN_3_NAME ,METRIC_NAME );


CREATE MULTISET TABLE ???.STG_BEA_PersonalConsumption_2_3_5 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      ROW_KEY BYTEINT,
      DOMAIN_NAME VARCHAR(52) CHARACTER SET LATIN NOT CASESPECIFIC,
      SUBDOMAIN_1_NAME VARCHAR(67) CHARACTER SET LATIN NOT CASESPECIFIC,
      SUBDOMAIN_2_NAME VARCHAR(57) CHARACTER SET LATIN NOT CASESPECIFIC,
      SUBDOMAIN_3_NAME VARCHAR(5) CHARACTER SET LATIN NOT CASESPECIFIC,
      "PERIOD_MMM-YYYY" VARCHAR(8) CHARACTER SET LATIN NOT CASESPECIFIC,
      METRIC_NAME VARCHAR(54) CHARACTER SET LATIN NOT CASESPECIFIC,
      METRIC_INDEX BYTEINT,
      METRIC_VALUE INTEGER,
      DATA_SOURCE_NAME VARCHAR(57) CHARACTER SET LATIN NOT CASESPECIFIC,
      DATA_SOURCE_DESC VARCHAR(66) CHARACTER SET LATIN NOT CASESPECIFIC)
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_BEA_PersonalConsumption_2_4_5 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      ROW_KEY SMALLINT,
      DOMAIN_NAME VARCHAR(33) CHARACTER SET LATIN NOT CASESPECIFIC,
      SUBDOMAIN_1_NAME VARCHAR(49) CHARACTER SET LATIN NOT CASESPECIFIC,
      SUBDOMAIN_2_NAME VARCHAR(57) CHARACTER SET LATIN NOT CASESPECIFIC,
      SUBDOMAIN_3_NAME VARCHAR(99) CHARACTER SET LATIN NOT CASESPECIFIC,
      SUBDOMAIN_4_NAME VARCHAR(90) CHARACTER SET LATIN NOT CASESPECIFIC,
      "PERIOD_MMM-YYYY" VARCHAR(8) CHARACTER SET LATIN NOT CASESPECIFIC,
      METRIC_NAME VARCHAR(53) CHARACTER SET LATIN NOT CASESPECIFIC,
      METRIC_INDEX BYTEINT,
      METRIC_VALUE INTEGER,
      DATA_SOURCE_NAME VARCHAR(57) CHARACTER SET LATIN NOT CASESPECIFIC,
      DATA_SOURCE_DESC VARCHAR(66) CHARACTER SET LATIN NOT CASESPECIFIC)
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_Consumer_Sentiment_Index ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      "Month" VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      "Year" VARCHAR(10) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Consumer_Sentiment_Index FLOAT,
      current_dttm TIMESTAMP(6))
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_COVID19_Datahub_LVL2 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      id VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      date_key TIMESTAMP(6),
      tests BIGINT,
      confirmed BIGINT,
      recovered BIGINT,
      deaths BIGINT,
      hosp BIGINT,
      vent BIGINT,
      icu BIGINT,
      population FLOAT,
      school_closing BIGINT,
      workplace_closing BIGINT,
      cancel_events BIGINT,
      gatherings_restrictions BIGINT,
      transport_closing BIGINT,
      stay_home_restrictions BIGINT,
      internal_movement_restrictions BIGINT,
      international_movement_restrictions BIGINT,
      information_campaigns BIGINT,
      testing_policy BIGINT,
      contact_tracing BIGINT,
      stringency_index FLOAT,
      iso_alpha_3 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      iso_alpha_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      iso_numeric FLOAT,
      currency VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      administrative_area_level BIGINT,
      administrative_area_level_1 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      administrative_area_level_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      administrative_area_level_3 FLOAT,
      latitude FLOAT,
      longitude FLOAT,
      "key" VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      key_google_mobility VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      key_apple_mobility VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      key_alpha_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      key_numeric FLOAT,
      current_dttm TIMESTAMP(6))
PRIMARY INDEX ( date_key );


CREATE MULTISET TABLE ???.STG_COVID19_Datahub_LVL3 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      id VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      date_key TIMESTAMP(6),
      tests BIGINT,
      confirmed BIGINT,
      recovered BIGINT,
      deaths BIGINT,
      hosp BIGINT,
      vent BIGINT,
      icu BIGINT,
      population FLOAT,
      school_closing BIGINT,
      workplace_closing BIGINT,
      cancel_events BIGINT,
      gatherings_restrictions BIGINT,
      transport_closing BIGINT,
      stay_home_restrictions BIGINT,
      internal_movement_restrictions BIGINT,
      international_movement_restrictions BIGINT,
      information_campaigns BIGINT,
      testing_policy BIGINT,
      contact_tracing BIGINT,
      stringency_index FLOAT,
      iso_alpha_3 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      iso_alpha_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      iso_numeric FLOAT,
      currency VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      administrative_area_level BIGINT,
      administrative_area_level_1 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      administrative_area_level_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      administrative_area_level_3 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      latitude FLOAT,
      longitude FLOAT,
      "key" VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      key_numeric FLOAT,
      key_google_mobility VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      key_apple_mobility FLOAT,
      key_alpha_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      current_dttm TIMESTAMP(6))
PRIMARY INDEX ( date_key );


CREATE MULTISET TABLE ???.STG_COVID19_NATIONAL_ESTIMATES ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      state VARCHAR(2) CHARACTER SET LATIN NOT CASESPECIFIC,
      statename VARCHAR(20) CHARACTER SET LATIN NOT CASESPECIFIC,
      collectionDate DATE FORMAT 'YYYY/MM/DD',
      InpatBeds_Occ_AnyPat_Est INTEGER,
      InpatBeds_Occ_AnyPat_LoCI INTEGER,
      InpatBeds_Occ_AnyPat_UpCI INTEGER,
      InpatBeds_Occ_AnyPat_Est_Avail INTEGER,
      InBedsOccAnyPat__Numbeds_Est DECIMAL(3,1),
      InBedsOccAnyPat__Numbeds_LoCI DECIMAL(3,1),
      InBedsOccAnyPat__Numbeds_UpCI DECIMAL(4,1),
      InpatBeds_Occ_COVID_Est INTEGER,
      InpatBeds_Occ_COVID_LoCI INTEGER,
      InpatBeds_Occ_COVID_UpCI INTEGER,
      InBedsOccCOVID__Numbeds_Est DECIMAL(3,1),
      InBedsOccCOVID__Numbeds_LoCI DECIMAL(3,1),
      InBedsOccCOVID__Numbeds_UpCI DECIMAL(3,1),
      ICUBeds_Occ_AnyPat_Est INTEGER,
      ICUBeds_Occ_AnyPat_LoCI INTEGER,
      ICUBeds_Occ_AnyPat_UpCI INTEGER,
      ICUBeds_Occ_AnyPat_Est_Avail INTEGER,
      ICUBedsOccAnyPat__N_ICUBeds_Est DECIMAL(4,1),
      ICUBedsOccAnyPat__N_ICUBeds_LoCI DECIMAL(3,1),
      ICUBedsOccAnyPat__N_ICUBeds_UpCI DECIMAL(4,1),
      Notes VARCHAR(196) CHARACTER SET LATIN NOT CASESPECIFIC,
      label1 VARCHAR(77) CHARACTER SET LATIN NOT CASESPECIFIC,
      label2 VARCHAR(7) CHARACTER SET LATIN NOT CASESPECIFIC,
      label3 VARCHAR(18) CHARACTER SET LATIN NOT CASESPECIFIC,
      label4 VARCHAR(36) CHARACTER SET LATIN NOT CASESPECIFIC)
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_covid19_stats ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      date_key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      county VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      state VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      fips FLOAT,
      cases BIGINT,
      deaths BIGINT,
      current_dttm TIMESTAMP(6))
PRIMARY INDEX ( date_key );


CREATE MULTISET TABLE ???.STG_CO_EST2019 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      SUMLEV BYTEINT,
      REGION BYTEINT,
      DIVISION BYTEINT,
      STATE BYTEINT,
      COUNTY SMALLINT,
      STNAME VARCHAR(20) CHARACTER SET LATIN NOT CASESPECIFIC,
      CTYNAME VARCHAR(33) CHARACTER SET LATIN NOT CASESPECIFIC,
      CENSUS2010POP INTEGER,
      ESTIMATESBASE2010 INTEGER,
      POPESTIMATE2010 INTEGER,
      POPESTIMATE2011 INTEGER,
      POPESTIMATE2012 INTEGER,
      POPESTIMATE2013 INTEGER,
      POPESTIMATE2014 INTEGER,
      POPESTIMATE2015 INTEGER,
      POPESTIMATE2016 INTEGER,
      POPESTIMATE2017 INTEGER,
      POPESTIMATE2018 INTEGER,
      POPESTIMATE2019 INTEGER,
      NPOPCHG_2010 INTEGER,
      NPOPCHG_2011 INTEGER,
      NPOPCHG_2012 INTEGER,
      NPOPCHG_2013 INTEGER,
      NPOPCHG_2014 INTEGER,
      NPOPCHG_2015 INTEGER,
      NPOPCHG_2016 INTEGER,
      NPOPCHG_2017 INTEGER,
      NPOPCHG_2018 INTEGER,
      NPOPCHG_2019 INTEGER,
      BIRTHS2010 INTEGER,
      BIRTHS2011 INTEGER,
      BIRTHS2012 INTEGER,
      BIRTHS2013 INTEGER,
      BIRTHS2014 INTEGER,
      BIRTHS2015 INTEGER,
      BIRTHS2016 INTEGER,
      BIRTHS2017 INTEGER,
      BIRTHS2018 INTEGER,
      BIRTHS2019 INTEGER,
      DEATHS2010 INTEGER,
      DEATHS2011 INTEGER,
      DEATHS2012 INTEGER,
      DEATHS2013 INTEGER,
      DEATHS2014 INTEGER,
      DEATHS2015 INTEGER,
      DEATHS2016 INTEGER,
      DEATHS2017 INTEGER,
      DEATHS2018 INTEGER,
      DEATHS2019 INTEGER,
      NATURALINC2010 INTEGER,
      NATURALINC2011 INTEGER,
      NATURALINC2012 INTEGER,
      NATURALINC2013 INTEGER,
      NATURALINC2014 INTEGER,
      NATURALINC2015 INTEGER,
      NATURALINC2016 INTEGER,
      NATURALINC2017 INTEGER,
      NATURALINC2018 INTEGER,
      NATURALINC2019 INTEGER,
      INTERNATIONALMIG2010 SMALLINT,
      INTERNATIONALMIG2011 INTEGER,
      INTERNATIONALMIG2012 INTEGER,
      INTERNATIONALMIG2013 INTEGER,
      INTERNATIONALMIG2014 INTEGER,
      INTERNATIONALMIG2015 INTEGER,
      INTERNATIONALMIG2016 INTEGER,
      INTERNATIONALMIG2017 INTEGER,
      INTERNATIONALMIG2018 INTEGER,
      INTERNATIONALMIG2019 INTEGER,
      DOMESTICMIG2010 SMALLINT,
      DOMESTICMIG2011 INTEGER,
      DOMESTICMIG2012 INTEGER,
      DOMESTICMIG2013 INTEGER,
      DOMESTICMIG2014 INTEGER,
      DOMESTICMIG2015 INTEGER,
      DOMESTICMIG2016 INTEGER,
      DOMESTICMIG2017 INTEGER,
      DOMESTICMIG2018 INTEGER,
      DOMESTICMIG2019 INTEGER,
      NETMIG2010 INTEGER,
      NETMIG2011 INTEGER,
      NETMIG2012 INTEGER,
      NETMIG2013 INTEGER,
      NETMIG2014 INTEGER,
      NETMIG2015 INTEGER,
      NETMIG2016 INTEGER,
      NETMIG2017 INTEGER,
      NETMIG2018 INTEGER,
      NETMIG2019 INTEGER,
      RESIDUAL2010 SMALLINT,
      RESIDUAL2011 SMALLINT,
      RESIDUAL2012 SMALLINT,
      RESIDUAL2013 SMALLINT,
      RESIDUAL2014 SMALLINT,
      RESIDUAL2015 SMALLINT,
      RESIDUAL2016 SMALLINT,
      RESIDUAL2017 SMALLINT,
      RESIDUAL2018 SMALLINT,
      RESIDUAL2019 SMALLINT,
      GQESTIMATESBASE2010 INTEGER,
      GQESTIMATES2010 INTEGER,
      GQESTIMATES2011 INTEGER,
      GQESTIMATES2012 INTEGER,
      GQESTIMATES2013 INTEGER,
      GQESTIMATES2014 INTEGER,
      GQESTIMATES2015 INTEGER,
      GQESTIMATES2016 INTEGER,
      GQESTIMATES2017 INTEGER,
      GQESTIMATES2018 INTEGER,
      GQESTIMATES2019 INTEGER,
      RBIRTH2011 DECIMAL(12,10),
      RBIRTH2012 DECIMAL(12,10),
      RBIRTH2013 DECIMAL(12,10),
      RBIRTH2014 DECIMAL(12,10),
      RBIRTH2015 DECIMAL(12,10),
      RBIRTH2016 DECIMAL(12,10),
      RBIRTH2017 DECIMAL(12,10),
      RBIRTH2018 DECIMAL(12,10),
      RBIRTH2019 DECIMAL(12,10),
      RDEATH2011 DECIMAL(12,10),
      RDEATH2012 DECIMAL(12,10),
      RDEATH2013 DECIMAL(12,10),
      RDEATH2014 DECIMAL(12,10),
      RDEATH2015 DECIMAL(12,10),
      RDEATH2016 DECIMAL(12,10),
      RDEATH2017 DECIMAL(12,10),
      RDEATH2018 DECIMAL(12,10),
      RDEATH2019 DECIMAL(12,10),
      RNATURALINC2011 DECIMAL(13,10),
      RNATURALINC2012 DECIMAL(13,10),
      RNATURALINC2013 DECIMAL(13,10),
      RNATURALINC2014 DECIMAL(13,10),
      RNATURALINC2015 DECIMAL(13,10),
      RNATURALINC2016 DECIMAL(13,10),
      RNATURALINC2017 DECIMAL(13,10),
      RNATURALINC2018 DECIMAL(13,10),
      RNATURALINC2019 DECIMAL(13,10),
      RINTERNATIONALMIG2011 DECIMAL(12,10),
      RINTERNATIONALMIG2012 DECIMAL(12,10),
      RINTERNATIONALMIG2013 DECIMAL(12,10),
      RINTERNATIONALMIG2014 DECIMAL(12,10),
      RINTERNATIONALMIG2015 DECIMAL(12,10),
      RINTERNATIONALMIG2016 DECIMAL(12,10),
      RINTERNATIONALMIG2017 DECIMAL(12,10),
      RINTERNATIONALMIG2018 DECIMAL(12,10),
      RINTERNATIONALMIG2019 DECIMAL(12,10),
      RDOMESTICMIG2011 DECIMAL(14,10),
      RDOMESTICMIG2012 DECIMAL(14,10),
      RDOMESTICMIG2013 DECIMAL(14,10),
      RDOMESTICMIG2014 DECIMAL(14,10),
      RDOMESTICMIG2015 DECIMAL(13,10),
      RDOMESTICMIG2016 DECIMAL(14,10),
      RDOMESTICMIG2017 DECIMAL(14,10),
      RDOMESTICMIG2018 DECIMAL(13,10),
      RDOMESTICMIG2019 DECIMAL(14,10),
      RNETMIG2011 DECIMAL(14,10),
      RNETMIG2012 DECIMAL(13,10),
      RNETMIG2013 DECIMAL(13,10),
      RNETMIG2014 DECIMAL(14,10),
      RNETMIG2015 DECIMAL(13,10),
      RNETMIG2016 DECIMAL(14,10),
      RNETMIG2017 DECIMAL(14,10),
      RNETMIG2018 DECIMAL(13,10),
      RNETMIG2019 DECIMAL(14,10))
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_Fuel_Production ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      date_key TIMESTAMP(6),
      "4-Week Avg U.S. Product Supplied of Petroleum Products  (Thousand Barrels per Day)" FLOAT,
      "4-Week Avg U.S. Product Supplied of Finished Motor Gasoline  (Thousand Barrels per Day)" FLOAT,
      "4-Week Avg U.S. Product Supplied of Kerosene-Type Jet Fuel  (Thousand Barrels per Day)" FLOAT,
      "4-Week Avg U.S. Product Supplied of Distillate Fuel Oil  (Thousand Barrels per Day)" FLOAT,
      "4-Week Avg U.S. Product Supplied of Residual Fuel Oil  (Thousand Barrels per Day)" FLOAT,
      "4-Week Avg U.S. Product Supplied of Propane and Propylene  (Thousand Barrels per Day)" FLOAT,
      "4-Week Avg U.S. Product Supplied of Other Oils  (Thousand Barrels per Day)" FLOAT,
      current_dttm TIMESTAMP(6))
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_Google_Mobility ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      country_region_code VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      country_region VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      sub_region_1 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      sub_region_2 VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      iso_3166_2_code VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      census_fips_code VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      date_key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      retail_and_recreation_percent_change_from_baseline VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      grocery_and_pharmacy_percent_change_from_baseline VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      parks_percent_change_from_baseline VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      transit_stations_percent_change_from_baseline VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      workplaces_percent_change_from_baseline VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      residential_percent_change_from_baseline VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      current_dttm TIMESTAMP(6))
PRIMARY INDEX ( date_key );


CREATE MULTISET TABLE ???.STG_Google_Search_IOT ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      Metric_value INTEGER,
      isPartial BYTEINT,
      Trend_Name VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Metric_Name VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      current_dttm TIMESTAMP(6),
      Keyword_List VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Cat_CD VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      "Type" VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      "date" TIMESTAMP(6))
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_Hospitalization_all_locs ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      V1 BIGINT,
      location_name VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      "date" VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      location_id BIGINT,
      allbed_mean FLOAT,
      allbed_lower FLOAT,
      allbed_upper FLOAT,
      ICUbed_mean FLOAT,
      ICUbed_lower FLOAT,
      ICUbed_upper FLOAT,
      InvVen_mean FLOAT,
      InvVen_lower FLOAT,
      InvVen_upper FLOAT,
      admis_mean FLOAT,
      admis_lower FLOAT,
      admis_upper FLOAT,
      newICU_mean FLOAT,
      newICU_lower FLOAT,
      newICU_upper FLOAT,
      bedover_mean FLOAT,
      bedover_lower FLOAT,
      bedover_upper FLOAT,
      icuover_mean FLOAT,
      icuover_lower FLOAT,
      icuover_upper FLOAT,
      deaths_mean FLOAT,
      deaths_lower FLOAT,
      deaths_upper FLOAT,
      totdea_mean FLOAT,
      totdea_lower FLOAT,
      totdea_upper FLOAT,
      deaths_mean_smoothed FLOAT,
      deaths_lower_smoothed FLOAT,
      deaths_upper_smoothed FLOAT,
      totdea_mean_smoothed FLOAT,
      totdea_lower_smoothed FLOAT,
      totdea_upper_smoothed FLOAT,
      mobility_data_type VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      mobility_composite FLOAT,
      total_tests_data_type VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      total_tests FLOAT,
      confirmed_infections FLOAT,
      est_infections_mean FLOAT,
      est_infections_lower FLOAT,
      est_infections_upper FLOAT,
      current_dttm TIMESTAMP(6),
      Path_Update_Dt VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC)
NO PRIMARY INDEX ;



CREATE MULTISET TABLE ???.STG_Labor_Stats_CUSR0000SA0 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      Year_Key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Period_Key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Period_Month VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      latest VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Metric_Val VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      footnotes VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      series_id VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      current_dttm TIMESTAMP(6))
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_Labor_Stats_LNS13000000 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      Year_Key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Period_Key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Period_Month VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      latest VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Metric_Val VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      footnotes VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      series_id VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      current_dttm TIMESTAMP(6))
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_Labor_Stats_LNS14000000 ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      Year_Key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Period_Key VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Period_Month VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      latest VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Metric_Val VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      footnotes VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      series_id VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      current_dttm TIMESTAMP(6))
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_Summary_stats_all_locs ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      location_name VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      location_id BIGINT,
      peak_bed_day_mean VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      peak_bed_day_lower VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      peak_bed_day_upper VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      peak_icu_bed_day_mean VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      peak_icu_bed_day_lower VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      peak_icu_bed_day_upper VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      peak_vent_day_mean VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      peak_vent_day_lower VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      peak_vent_day_upper VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      all_bed_capacity FLOAT,
      icu_bed_capacity FLOAT,
      all_bed_usage FLOAT,
      icu_bed_usage FLOAT,
      available_all_nbr FLOAT,
      available_icu_nbr FLOAT,
      travel_limit_start_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      travel_limit_end_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      stay_home_start_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      stay_home_end_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      educational_fac_start_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      educational_fac_end_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      any_gathering_restrict_start_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      any_gathering_restrict_end_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      any_business_start_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      any_business_end_date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      "all_non-ess_business_start_date" VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      "all_non-ess_business_end_date" VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      current_dttm TIMESTAMP(6),
      Path_Update_Dt VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC)
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_TSA_TRAVEL ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      Travel_Date VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      TravelThroughPut FLOAT,
      TravelThroughPutLastYear FLOAT)
NO PRIMARY INDEX ;


CREATE MULTISET TABLE ???.STG_US_CENSUS_SURVEY ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      Period VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      "Value" VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Metric_name VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      Data_source_desc VARCHAR(1024) CHARACTER SET UNICODE NOT CASESPECIFIC,
      current_dttm TIMESTAMP(6))
PRIMARY INDEX ( Period );


CREATE MULTISET TABLE ???.Transaltion_Table ,FALLBACK ,
     NO BEFORE JOURNAL,
     NO AFTER JOURNAL,
     CHECKSUM = DEFAULT,
     DEFAULT MERGEBLOCKRATIO,
     MAP = TD_MAP1
     (
      CLNSNG_CD VARCHAR(32) CHARACTER SET UNICODE NOT CASESPECIFIC,
      CLNSNG_SRC VARCHAR(200) CHARACTER SET UNICODE NOT CASESPECIFIC,
      CLNSNG_TRGT VARCHAR(200) CHARACTER SET UNICODE NOT CASESPECIFIC,
      CLNSNG_DESC VARCHAR(200) CHARACTER SET UNICODE NOT CASESPECIFIC)
PRIMARY INDEX ( CLNSNG_CD ,CLNSNG_SRC );


REPLACE VIEW ???.DIM_DASH_VIZ_METRIC_XREF_V AS
    LOCKING ROW FOR ACCESS
    SELECT *
        FROM ???.DIM_DASH_VIZ_METRIC_XREF
        WHERE CORP_ID = 1
            AND  CORP_FUNCTION = 'Generic'
            AND  DASHBOARD_VERSION = '1';
			

REPLACE VIEW ???.DIM_CALENDAR_V  AS
    LOCKING ROW FOR ACCESS
    SELECT 
        CALENDAR_DATE AS CAL_DATE_KEY,
        DAY_OF_WEEK   AS CAL_DAY_OF_WEEK,
        CONCAT('W',TRIM(WEEK_OF_YEAR),'-',TRIM(YEAR_OF_CALENDAR)) AS CAL_WEEK_YEAR,
        MIN(CALENDAR_DATE) OVER (PARTITION BY WEEK_OF_YEAR,YEAR_OF_CALENDAR
        ORDER BY CALENDAR_DATE) AS WEEK_START_DATE,
            MAX(CALENDAR_DATE) OVER (PARTITION BY WEEK_OF_YEAR,YEAR_OF_CALENDAR
        ORDER BY CALENDAR_DATE) AS WEEK_END_DATE,
            CONCAT('M',TRIM(MONTH_OF_YEAR),'-',TRIM(YEAR_OF_CALENDAR)) AS CAL_MONTH_YEAR,
            MIN(CALENDAR_DATE) OVER (PARTITION BY MONTH_OF_YEAR,YEAR_OF_CALENDAR
        ORDER BY CALENDAR_DATE) AS MONTH_START_DATE,
            MAX(CALENDAR_DATE) OVER (PARTITION BY MONTH_OF_YEAR,YEAR_OF_CALENDAR
        ORDER BY CALENDAR_DATE) AS MONTH_END_DATE,
            
        CASE
            WHEN DAY_OF_WEEK = 1 THEN CALENDAR_DATE + 6
            WHEN DAY_OF_WEEK = 2 THEN CALENDAR_DATE + 5
            WHEN DAY_OF_WEEK = 3 THEN CALENDAR_DATE + 4
            WHEN DAY_OF_WEEK = 4 THEN CALENDAR_DATE + 3
            WHEN DAY_OF_WEEK = 5 THEN CALENDAR_DATE + 2
            WHEN DAY_OF_WEEK = 6 THEN CALENDAR_DATE + 1
        ELSE CALENDAR_DATE
        END cal_day_sat,
            day_of_year,
            day_of_calendar day_of_cal_1900,
            WEEK_OF_YEAR --select *
        
        FROM SYS_CALENDAR.CALENDAR a
        WHERE CALENDAR_DATE BETWEEN DATE '2000-01-01' AND 
        DATE '2030-01-01';


REPLACE VIEW ???.DIM_GEO_LOCATION_V AS
    LOCKING ROW FOR ACCESS
    SELECT UID,
        GEO_GRANULARITY,
        Country_code,
        iso3,
        code3,
        FIPS,
        County,
        County_long,
            STATE_NAME,
            STATE_CODE,
            COUNTRY_NAME,
            Lat,
            Lon,
            Combined_Key,
            Population
        FROM ???.DIM_GEO_LOCATION_T
    UNION ALL
    SELECT 
        CAST(-1 AS INTEGER) uid,
        CAST('N/A    ' AS VARCHAR(7) CHARACTER SET UNICODE NOT CASESPECIFIC) GEO_GRANULARITY,
        CAST(NULL AS VARCHAR(2) CHARACTER SET LATIN NOT CASESPECIFIC) Country_code,
        CAST(NULL AS VARCHAR(3) CHARACTER SET LATIN NOT CASESPECIFIC) iso3,
        CAST(NULL AS INTEGER) code3,
        CAST(NULL AS INTEGER) FIPS,
        CAST(NULL AS VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC) County,
        CAST(NULL AS VARCHAR(135) CHARACTER SET LATIN NOT CASESPECIFIC) County_long,
        CAST(NULL AS VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC) STATE_NAME,
        CAST(NULL AS CHAR(2) CHARACTER SET LATIN NOT CASESPECIFIC) STATE_CODE,
        CAST(NULL AS VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC) COUNTRY_NAME,
        CAST(NULL AS FLOAT) Lat,
        CAST(NULL AS FLOAT) Lon,
        CAST(NULL AS VARCHAR(128) CHARACTER SET LATIN NOT CASESPECIFIC) Combined_Key,
        CAST(NULL AS INTEGER) Population
        FROM ???.DIM_GEO_LOCATION_T
        WHERE uid = 840;


REPLACE VIEW  ???.DIM_PEOPLE_LOCATION_V AS
    LOCKING ROW FOR ACCESS
    SELECT PL.*,
        LKP.STATE_NAME,
        LKP.COUNTY_NAME,
        LKP.MSA_NAME
        FROM ???.DIM_People_location PL
        LEFT JOIN ???.DIM_ZIPCODE_COUNTY_MSA_LKUP LKP ON 
        PL.ZIPCODE = LKP.ZIPCODE;


REPLACE VIEW  ???.DIM_SITE_ADDRESSES_V AS
    LOCKING ROW FOR ACCESS
    SELECT SA.*, LKP.STATE_NAME, LKP.COUNTY_NAME, LKP.MSA_NAME
    FROM ???.DIM_SITE_ADDRESSES SA
    LEFT JOIN ???.DIM_ZIPCODE_COUNTY_MSA_LKUP LKP ON 
         SA.ZIPCODE = LKP.ZIPCODE;


REPLACE VIEW ???.DIM_ZIPCODE_COUNTY_MSA_LKUP_V AS
LOCKING ROW FOR ACCESS
SELECT * FROM ???.DIM_ZIPCODE_COUNTY_MSA_LKUP;


REPLACE VIEW   ???.FACT_COVID19_DATAHUB_STATE_V AS
    LOCKING ROW FOR ACCESS
    SELECT   DATE_KEY,
        GEO_KEY,
        g.state_name,
        TESTED_CNT,
        CONFIRMED_CNT,
        RECOVERED_CNT,
        DEATH_CNT,
        HOSPITALIZED_CNT,
        ON_VENTILATOR_CNT,
        IN_ICU_CNT,
        SEVERE_CASE_CNT,
        
        COALESCE(TESTED_CNT- SUM(TESTED_CNT) OVER (PARTITION  BY geo_key
        ORDER BY geo_key,
            DATE_KEY  
        ROWS  BETWEEN   1 PRECEDING AND 1 PRECEDING),0)   AS TESTED_NEW_CNT,
            COALESCE(CONFIRMED_CNT- SUM(CONFIRMED_CNT) OVER (PARTITION  BY geo_key
        ORDER BY geo_key,
            DATE_KEY  
        ROWS  BETWEEN 1 PRECEDING AND 1 PRECEDING),0)  AS CONFIRMED_NEW_CNT,
            COALESCE(RECOVERED_CNT- SUM(RECOVERED_CNT) OVER (PARTITION  BY geo_key
        ORDER BY geo_key,
            DATE_KEY  
        ROWS  BETWEEN 1 PRECEDING AND 1 PRECEDING),0)  AS RECOVERED_NEW_CNT,
            COALESCE(DEATH_CNT- SUM(DEATH_CNT) OVER (PARTITION  BY geo_key
        ORDER BY geo_key,
            DATE_KEY  
        ROWS  BETWEEN 1 PRECEDING AND 1 PRECEDING),0)  AS DEATH_NEW_CNT,
            COALESCE(HOSPITALIZED_CNT- SUM(HOSPITALIZED_CNT) OVER (PARTITION  BY geo_key
        ORDER BY geo_key,
            DATE_KEY  
        ROWS  BETWEEN 1 PRECEDING AND 1 PRECEDING),0)  AS HOSPITALIZED_NEW_CNT,
            COALESCE(ON_VENTILATOR_CNT- SUM(ON_VENTILATOR_CNT) OVER (PARTITION  BY geo_key
        ORDER BY geo_key,
            DATE_KEY  
        ROWS  BETWEEN 1 PRECEDING AND 1 PRECEDING),0)  AS ON_VENTILATOR_NEW_CNT,
            COALESCE(IN_ICU_CNT- SUM(IN_ICU_CNT) OVER (PARTITION  BY geo_key
        ORDER BY geo_key,
            DATE_KEY  
        ROWS  BETWEEN 1 PRECEDING AND 1 PRECEDING),0)  AS IN_ICU_NEW_CNT,
            COALESCE(SEVERE_CASE_CNT- SUM(SEVERE_CASE_CNT) OVER (PARTITION  BY geo_key
        ORDER BY geo_key,
            DATE_KEY  
        ROWS  BETWEEN 1 PRECEDING AND 1 PRECEDING),0)  AS SEVERE_CASE_NEW_CNT,
            dl.POPULATION,
            SCHOOL_CLOSING,
            WORKPLACE_CLOSING,
            CANCEL_EVENTS,
            GATHERINGS_RESTRICTIONS,
            TRANSPORT_CLOSING,
            STAY_HOME_RESTRICTIONS,
            INTERNAL_MOVEMENT_RESTRICTIONS,
            INTERNATIONAL_MOVEMENT_RESTRICTIONS,
            INFORMATION_CAMPAIGNS,
            TESTING_POLICY,
            CONTACT_TRACING,
            STRINGENCY_INDEX,
            KEY_STR,
            KEY_NUMERIC,
            KEY_GOOGLE_MOBILITY,
            KEY_APPLE_MOBILITY,
            KEY_ALPHA_2,
            REC_INS_TS
        FROM ???.FACT_COVID19_DATAHUB_STATE dl
        JOIN ???.DIM_GEO_LOCATION_V g ON g.uid = dl.geo_key;


REPLACE VIEW   ???.FACT_COVID19_DATAHUB_V AS
    LOCKING ROW FOR ACCESS
    SELECT  DATE_KEY,
        GEO_KEY,
        TESTCNT tested_cnt,
        CONFIRMED_CNT,
        RECOVERED_CNT,
        DEATHs_CNT DEATH_CNT,
        HOSPITALIZED_CNT,
        ON_VENTILATOR_CNT,
        IN_ICU_CNT,
        SEVERE_CASE_CNT,
        POPULATION,
        SCHOOL_CLOSING,
        WORKPLACE_CLOSING,
        CANCEL_EVENTS,
        GATHERINGS_RESTRICTIONS,
        TRANSPORT_CLOSING,
        STAY_HOME_RESTRICTIONS,
        INTERNAL_MOVEMENT_RESTRICTIONS,
        INTERNATIONAL_MOVEMENT_RESTRICTIONS,
        INFORMATION_CAMPAIGNS,
        TESTING_POLICY,
        CONTACT_TRACING,
        STRINGENCY_INDEX,
        KEY_STR,
        KEY_NUMERIC,
        KEY_GOOGLE_MOBILITY,
        KEY_APPLE_MOBILITY,
        KEY_ALPHA_2,
        REC_INS_TS
        FROM ???.FACT_COVID19_DATAHUB;


REPLACE VIEW ???.FACT_COVID_MODEL_DATA_SUM_V AS
LOCKING ROW FOR ACCESS
SELECT G.COUNTY, G.STATE_CODE, G.STATE_NAME, G.COUNTRY_NAME,
       F.*
FROM ???.FACT_Covid_Model_Data_SUM F
JOIN ???.DIM_GEO_LOCATION_V G ON
F.GEO_KEY = G.UID;


REPLACE VIEW ???.FACT_INDICATOR_DASHBOARD_V  AS
    LOCKING ROW FOR ACCESS
    SELECT INDICATOR_KEY,
        DATE_KEY,
        DATE_GRANULARITY,
        GEO_KEY,
        GEO_GRANULARITY,
        DOMAIN_NAME,
        SUBDOMAIN_1_NAME,
        SUBDOMAIN_2_NAME,
        SUBDOMAIN_3_NAME,
        METRIC_NAME,
        METRIC_VALUE,
        METRIC_INDEX,
        DATA_SOURCE_NAME,
        DATA_SOURCE_DESC,
        REC_INS_TS,
        REC_UPD_TS
        FROM ???.FACT_INDICATOR_DASHBOARD_T2_P;


REPLACE VIEW ???.F_IND_DASH_COVID_NAT_ESTIMATES_V AS
    LOCKING ROW FOR ACCESS
    SELECT 

	STATE STATE_CD,
    STATENAME STATE_NAME,
    COLLECTIONDATE DATE_KEY,
    INPATBEDS_OCC_ANYPAT_EST,
    INPATBEDS_OCC_ANYPAT_LOCI,
    INPATBEDS_OCC_ANYPAT_UPCI,
    INPATBEDS_OCC_ANYPAT_EST_AVAIL,
    INBEDSOCCANYPAT__NUMBEDS_EST,
    INBEDSOCCANYPAT__NUMBEDS_LOCI,
    INBEDSOCCANYPAT__NUMBEDS_UPCI,
    INPATBEDS_OCC_COVID_EST,
    INPATBEDS_OCC_COVID_LOCI,
    INPATBEDS_OCC_COVID_UPCI,
    INBEDSOCCCOVID__NUMBEDS_EST,
    INBEDSOCCCOVID__NUMBEDS_LOCI,
    INBEDSOCCCOVID__NUMBEDS_UPCI,
    ICUBEDS_OCC_ANYPAT_EST,
    ICUBEDS_OCC_ANYPAT_LOCI,
    ICUBEDS_OCC_ANYPAT_UPCI,
    ICUBEDS_OCC_ANYPAT_EST_AVAIL,
    ICUBEDSOCCANYPAT__N_ICUBEDS_EST,
    ICUBEDSOCCANYPAT__N_ICUBEDS_LOCI,
    ICUBEDSOCCANYPAT__N_ICUBEDS_UPCI,
    NOTES,
    LABEL1,
    LABEL2,
    LABEL3,
    LABEL4
    FROM ???.STG_COVID19_NATIONAL_ESTIMATES;


REPLACE VIEW ???.F_IND_DASH_Covid_Projections_Curr_V AS
    LOCKING ROW FOR ACCESS
    SELECT *
        FROM ???.FACT_Covid_Model_Data   f
        WHERE geo_key BETWEEN 83999999 AND 84099999 -- us only
        	QUALIFY dense_rank() OVER(partition by geo_key
            ORDER BY date_key  DESC)  =1;


REPLACE VIEW ???.F_IND_DASH_Covid_Projections_Prev_V AS
    LOCKING ROW FOR ACCESS
    SELECT  
            f.*
        FROM ???.FACT_Covid_Model_Data   f
        WHERE geo_key BETWEEN 83999999 AND 84099999 -- us only
        QUALIFY DENSE_RANK() OVER(PARTITION BY geo_key
        ORDER BY date_key  DESC)  = 2;


REPLACE VIEW ???.F_IND_DASH_Covid_Summary_V  AS
    LOCKING ROW FOR ACCESS
    SELECT *
        FROM ???.FACT_COVID_MODEL_DATA_SUM;


REPLACE VIEW   ???.F_IND_DASH_DataHub_V AS
    LOCKING ROW FOR ACCESS
    SELECT  DATE_KEY,
        GEO_KEY,
        g.county,
        g.county_long,
        g.state_name,
        TESTCNT tested_cnt,
        CONFIRMED_CNT,
        RECOVERED_CNT,
        DEATHs_CNT DEATH_CNT,
        HOSPITALIZED_CNT,
        ON_VENTILATOR_CNT,
        IN_ICU_CNT,
        SEVERE_CASE_CNT,
        dh.POPULATION,
        SCHOOL_CLOSING,
        WORKPLACE_CLOSING,
        CANCEL_EVENTS,
        GATHERINGS_RESTRICTIONS,
        TRANSPORT_CLOSING,
        STAY_HOME_RESTRICTIONS,
        INTERNAL_MOVEMENT_RESTRICTIONS,
        INTERNATIONAL_MOVEMENT_RESTRICTIONS,
        INFORMATION_CAMPAIGNS,
        TESTING_POLICY,
        CONTACT_TRACING,
        STRINGENCY_INDEX,
        KEY_STR,
        KEY_NUMERIC,
        KEY_GOOGLE_MOBILITY,
        KEY_APPLE_MOBILITY,
        KEY_ALPHA_2,
        REC_INS_TS
        FROM ???.FACT_COVID19_DATAHUB dh
         join ???.DIM_GEO_LOCATION_V g on g.uid = dh.geo_key;



REPLACE VIEW ???.F_IND_DASH_GOOGLE_TRENDS_V AS
LOCKING ROW FOR ACCESS
SELECT * FROM ???.F_IND_DASH_GOOGLE_TRENDS;



REPLACE VIEW ???.F_IND_DASH_GOOGLE_SEARCH_TRENDS_VIZ_V AS
    LOCKING ROW FOR ACCESS
    WITH t1 AS (SELECT   MAX(date_key) max_dt FROM ???.F_IND_DASH_GOOGLE_TRENDS_V )   
    SELECT
        SNAPSHOT_DATE,
        SNAPSHOT_WEEK,
        CURR_PREV_FLAG,
        DATE_KEY,
        COUNTY,
        STATE_CODE,
        STATE_NAME,
        COUNTRY_NAME,
        TREND_NAME,
        METRIC_PERC_CHANGE_BASELINE,
        METRIC_7MAVG_PERC_CHANGE_BASELINE
        FROM 
        (
        SELECT
            DT.SNAPSHOT_DATE,
            DT.SNAPSHOT_WEEK,
            CASE WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
                 THEN DT.CURR_PREV_FLAG
            END AS CURR_PREV_FLAG,
            F.DATE_KEY,
            G.COUNTY,
            G.STATE_NAME,
            G.STATE_CODE,
            G.POPULATION,
            G.COUNTRY_NAME,
            F.TREND_NAME,
            F.METRIC_INDEX AS METRIC_PERC_CHANGE_BASELINE,
            CAST(AVG(F.METRIC_INDEX)  OVER (PARTITION BY F.GEO_KEY, F.TREND_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5)) METRIC_7MAVG_PERC_CHANGE_BASELINE
        FROM ???.F_IND_DASH_GOOGLE_TRENDS_V F  
        JOIN ???.DIM_GEO_LOCATION_V G ON
             F.GEO_KEY = G.UID
        JOIN (
              SELECT 
                MAX(WEEK_END_DATE) OVER () AS SNAPSHOT_DATE,
                MAX(CAL_WEEK_YEAR) OVER () AS SNAPSHOT_WEEK,
                MIN(WEEK_START_DATE) OVER () AS FIL_START_DATE_KEY,
                MAX(WEEK_END_DATE) OVER () FIL_END_DATE_KEY,  
                CASE
                    WHEN RNK =1 THEN 'CURR'
                    WHEN RNK =2 THEN 'PREV'
                ELSE 'PREV-1'
                END CURR_PREV_FLAG,
                RANK() OVER (ORDER BY WEEK_END_DATE DESC) RNK,
                DT.*
              FROM ???.DIM_CALENDAR_V DT
              WHERE CAL_DATE_KEY IN ((SELECT max_dt FROM t1) - 7, (SELECT max_dt FROM t1) -14, (SELECT max_dt FROM t1)-21)
             ) DT ON
            F.DATE_KEY BETWEEN DT.FIL_START_DATE_KEY AND DT.FIL_END_DATE_KEY
        ) T
        WHERE CURR_PREV_FLAG IN ('CURR','PREV')
        QUALIFY RANK() OVER (PARTITION BY CURR_PREV_FLAG ORDER BY DATE_KEY DESC) = 1;



REPLACE VIEW ???.F_IND_DASH_HEALTH_VIZ_V AS
LOCKING ROW FOR ACCESS
SELECT
 SNAPSHOT_DATE,
 SNAPSHOT_WEEK,
 CURR_PREV_FLAG,
 GEO_KEY,
 COUNTY,
 STATE_CODE,
 STATE_NAME,
 COUNTY_POPULATION,
 COUNTY_POP_RNK,
 CASES_TODATE_PER100K,  -- cases to-date per 100K population
 CASES_TODATE_WK,       -- cases to-date for snapshot week
 NEW_CASES_WK,          -- new cases for snapshot week
 DEATHS_TODATE_WK,      -- deaths to-date for snapshot week
 NEW_DEATHS_WK,         -- new deaths for snapshot week
 NEW_CASES_7MAVG,       -- new cases 7MAVG for last day of snapshot week    
 NEW_CASES_7MAVG_100K,  -- new cases 7MAVG/100k pop for last day of snapshot week    
 NEW_DEATHS_7MAVG,      -- new deaths 7MAVG for last day of snapshot week
 NEW_DEATHS_7MAVG_100K, -- new deaths 7MAVG/100k pop for last day of snapshot week
 MAX(RECOVERY_FLAG) OVER (PARTITION BY COUNTY, STATE_NAME, CURR_PREV_FLAG ORDER BY 1) AS RECOVERY_FLAG,
 MIN(SAFE_FLAG) OVER (PARTITION BY COUNTY, STATE_NAME, CURR_PREV_FLAG ORDER BY 1) AS SAFE_FLAG,
 MAX(SURGE_FLAG)  OVER (PARTITION BY COUNTY, STATE_NAME, CURR_PREV_FLAG ORDER BY 1)AS SURGE_FLAG
FROM
(
 SELECT 
   SNAPSHOT_DATE,
   SNAPSHOT_WEEK,
   CURR_PREV_FLAG,
   DATE_KEY,
   GEO_KEY,
   COUNTY,
   STATE_CODE,
   STATE_NAME,
   POPULATION AS COUNTY_POPULATION,
   COUNTY_POP_RNK,
   CASES_TODATE_PER100K,
   CASES_TODATE_WK,
   NEW_CASES_WK,
   DEATHS_TODATE_WK,
   NEW_DEATHS_WK,
   NEW_CASES_7MAVG,
   NEW_CASES_7MAVG_100K,
   NEW_DEATHS_7MAVG,
   NEW_DEATHS_7MAVG_100K,
   CASE WHEN NEW_CASES_7MAVG_100K                                                                         < 4 AND
             LEAD(NEW_CASES_7MAVG_100K,1 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,2 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,3 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,4 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,5 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,6 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,7 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,8 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,9 ) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,10) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,11) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,12) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 AND
			 LEAD(NEW_CASES_7MAVG_100K,13) OVER  (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) < 4 
	    THEN 1
		ELSE 0
   END AS SAFE_FLAG,
   CASE WHEN SAFE_FLAG = 0 AND
             LEAD(NEW_CASES_7MAVG_100K,1 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  NEW_CASES_7MAVG_100K AND
             LEAD(NEW_CASES_7MAVG_100K,2 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,1 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,3 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,2 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,4 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,3 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,5 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,4 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,6 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,5 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,7 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,6 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,8 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,7 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,9 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,8 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,10) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,9 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,11) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,10) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,12) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,11) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,13) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,12) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
             LEAD(NEW_CASES_7MAVG_100K,14) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) >  LEAD(NEW_CASES_7MAVG_100K,13) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC)
         THEN 1
         ELSE 0
   END AS RECOVERY_FLAG,
   CASE WHEN SAFE_FLAG = 0 AND
             LEAD(NEW_CASES_WK,7 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  NEW_CASES_WK AND  
			 LEAD(NEW_CASES_WK,14) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_WK,7 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC)
	    THEN 1
		ELSE 0
   END AS SURGE_FLAG
   --CASE WHEN NEW_CASES_7MAVG_100K >= 4 AND
   --          LEAD(NEW_CASES_7MAVG_100K,1 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  NEW_CASES_7MAVG_100K AND
   --          LEAD(NEW_CASES_7MAVG_100K,2 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,1 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
   --          LEAD(NEW_CASES_7MAVG_100K,3 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,2 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
   --          LEAD(NEW_CASES_7MAVG_100K,4 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,3 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
   --          LEAD(NEW_CASES_7MAVG_100K,5 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,4 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
   --          LEAD(NEW_CASES_7MAVG_100K,6 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,5 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
	--		   LEAD(NEW_CASES_7MAVG_100K,7 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,6 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
	--		   LEAD(NEW_CASES_7MAVG_100K,8 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,7 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
	--		   LEAD(NEW_CASES_7MAVG_100K,9 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,8 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
	--		   LEAD(NEW_CASES_7MAVG_100K,10) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,9 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
	--		   LEAD(NEW_CASES_7MAVG_100K,11) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,10 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
	--		   LEAD(NEW_CASES_7MAVG_100K,12) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,11 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
	--		   LEAD(NEW_CASES_7MAVG_100K,13) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,12 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) AND
	--		   LEAD(NEW_CASES_7MAVG_100K,14 ) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC) <  LEAD(NEW_CASES_7MAVG_100K,13) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC)
   --      THEN 1
   --      ELSE 0
   --END AS SURGE_FLAG
 FROM
 (
  SELECT
    SNAPSHOT_DATE,
    SNAPSHOT_WEEK,
    CURR_PREV_FLAG,
    DATE_KEY,
	GEO_KEY,
    COUNTY,
    STATE_CODE,
    STATE_NAME,
    POPULATION,
    DENSE_RANK() OVER (PARTITION BY SNAPSHOT_DATE,COUNTRY_NAME ORDER BY POPULATION DESC)                                                                             AS COUNTY_POP_RNK,
    MAX(ROUND(CAST(CASES_TODATE*100000 AS DECIMAL(38,5))/POPULATION,0)) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC)                                AS CASES_TODATE_PER100K,
	MAX(CASES_TODATE) OVER (PARTITION BY COUNTY, STATE_NAME, CURR_PREV_FLAG ORDER BY DATE_KEY DESC)                                                                  AS CASES_TODATE_WK,
	SUM(NEW_CASES) OVER (PARTITION BY COUNTY, STATE_NAME, CURR_PREV_FLAG ORDER BY DATE_KEY DESC)                                                                     AS NEW_CASES_WK,
	MAX(DEATHS_TODATE) OVER (PARTITION BY COUNTY, STATE_NAME, CURR_PREV_FLAG ORDER BY DATE_KEY DESC)                                                                 AS DEATHS_TODATE_WK,
	SUM(NEW_DEATHS) OVER (PARTITION BY COUNTY, STATE_NAME, CURR_PREV_FLAG ORDER BY DATE_KEY DESC)                                                                    AS NEW_DEATHS_WK,
    CAST(AVG(NEW_CASES)  OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5))                    AS NEW_CASES_7MAVG,
	CAST(AVG(NEW_CASES)  OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5))*100000/POPULATION  AS NEW_CASES_7MAVG_100K,
    CAST(AVG(NEW_DEATHS) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5))                    AS NEW_DEATHS_7MAVG,
	CAST(AVG(NEW_DEATHS) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5))*100000/POPULATION  AS NEW_DEATHS_7MAVG_100K
  FROM
  (
    SELECT
        DT.SNAPSHOT_DATE,
        DT.SNAPSHOT_WEEK,
        CASE WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
             THEN DT.CURR_PREV_FLAG
        END AS CURR_PREV_FLAG,
        F.DATE_KEY,
		F.GEO_KEY,
        G.COUNTY,
        G.STATE_NAME,
        G.STATE_CODE,
        G.POPULATION,
        G.COUNTRY_NAME,
        SUM(CASE WHEN UPPER(F.METRIC_NAME) = 'CASES TO-DATE'
             THEN METRIC_VALUE
        END) AS CASES_TODATE,
        SUM(CASE WHEN UPPER(F.METRIC_NAME) = 'NEW DAILY CASES'
             THEN METRIC_VALUE
             END) AS NEW_CASES,
        SUM(CASE WHEN UPPER(F.METRIC_NAME) = 'DEATHS TO-DATE'
             THEN METRIC_VALUE
        END) AS DEATHS_TODATE,
        SUM(CASE WHEN UPPER(F.METRIC_NAME) = 'NEW DAILY DEATHS'
             THEN METRIC_VALUE
             END) AS NEW_DEATHS
    FROM 
     ???.FACT_INDICATOR_DASHBOARD_V F 
     JOIN ???.DIM_GEO_LOCATION_V G ON
     F.GEO_KEY = G.UID
     JOIN (SELECT 
       		MAX(WEEK_END_DATE) OVER () AS SNAPSHOT_DATE,
       		MAX(CAL_WEEK_YEAR) OVER () AS SNAPSHOT_WEEK,
       		MIN(WEEK_START_DATE) OVER () AS FIL_START_DATE_KEY,
       		MAX(WEEK_END_DATE) OVER () FIL_END_DATE_KEY,
       		CASE WHEN RNK =1 THEN 'CURR'
            	 WHEN RNK =2 THEN 'PREV'
				 WHEN RNK =3 THEN 'PREV-1'
            	 ELSE 'PREV-2'
       		END CURR_PREV_FLAG,
       		RANK() OVER (ORDER BY WEEK_END_DATE DESC) RNK,
       		DT.*
    	   FROM 
            ???.DIM_CALENDAR_V DT
			LEFT JOIN (
                       SELECT MAX(DATE_KEY) MAX_DT
                       FROM ???.FACT_INDICATOR_DASHBOARD_V F  
                       JOIN ???.DIM_GEO_LOCATION_V G ON
                            F.GEO_KEY = G.UID
                       WHERE F.DOMAIN_NAME = 'Covid19 NYT' AND  
                             F.GEO_GRANULARITY = 'COUNTY'                      
                      ) MAXDT ON 1=1
           WHERE CAL_DATE_KEY IN (MAX_DT-7,MAX_DT-14,MAX_DT-21, MAX_DT-28)
          ) DT ON
      F.DATE_KEY BETWEEN DT.FIL_START_DATE_KEY AND DT.FIL_END_DATE_KEY
    WHERE 
     F.DOMAIN_NAME = 'Covid19 NYT' AND
     F.GEO_GRANULARITY = 'COUNTY' 
    GROUP BY 1,2,3,4,5,6,7,8,9,10
  ) T
  WHERE CURR_PREV_FLAG IS NOT NULL
 ) T1
--WHERE CURR_PREV_FLAG IN ('CURR','PREV','PREV-1')
) T2
WHERE CURR_PREV_FLAG IN ('CURR','PREV')
QUALIFY RANK() OVER (PARTITION BY COUNTY, STATE_NAME, CURR_PREV_FLAG ORDER BY DATE_KEY DESC) = 1;


REPLACE VIEW ???.F_IND_DASH_MACROECONOMICS_GEO_MONTHLY_V AS
    LOCKING ROW FOR ACCESS
    SELECT 
        DT.SNAPSHOT_DATE,
        DT.SNAPSHOT_MONTH,
        FT.DATE_KEY,
        FT.MONTH_KEY,
        FT.WEEK_NUM,
        FT.GEO_GRANULARITY,
        FT.COUNTY,
        FT.STATE_CODE,
        FT.STATE_NAME,
        FT.COUNTRY_NAME,
        FT.POPULATION,
        FT.METRIC_NAME,
        FT.METRIC_DISPLAY_SHORT_NAME,
		FT.METRIC_UOM,
		FT.DASH_VIZ_DISPLAY_NAME,
        FT.METRIC_VALUE
    FROM
       (
        SELECT 
            DATE_KEY,
            DATE_KEY - EXTRACT(DAY FROM DATE_KEY)+1 AS MONTH_KEY,
            0 AS WEEK_NUM,
            UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
            G.COUNTY,
            G.STATE_CODE,
            G.STATE_NAME,
            G.COUNTRY_NAME,
            G.POPULATION,
            MT.METRIC_DISPLAY_NAME AS METRIC_NAME,
            MT.METRIC_DISPLAY_SHORT_NAME,
		    MT.METRIC_UOM,
            MT.DASH_VIZ_DISPLAY_NAME,
            CASE WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'I' 
			     THEN F.METRIC_INDEX
                 WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'V' 
			     THEN F.METRIC_VALUE
            END AS METRIC_VALUE,
            F.DATA_SOURCE_NAME
        FROM ???.FACT_INDICATOR_DASHBOARD_V F
             JOIN ???.DIM_DASH_VIZ_METRIC_XREF_V MT  ON 
                  MT.SEMANTIC_VIEW_NAME             = 'F_IND_DASH_MACROECONOMICS_VIZ_V' AND
                  F.METRIC_NAME                     = MT.METRIC_NAME AND 
                  F.DATA_SOURCE_NAME                = MT.DATA_SOURCE_NAME  AND
                  DECODE(F.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_1_NAME,'?')) = DECODE(MT.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_1_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_2_NAME,'?')) = DECODE(MT.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_2_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_3_NAME,'?')) = DECODE(MT.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_3_NAME,'?'))
            JOIN ???.DIM_GEO_LOCATION_V G ON 
                  F.GEO_KEY = G.UID
            LEFT JOIN 
			(
             SELECT    
			 MAX(DATE_KEY) MAX_DT
             FROM ???.FACT_INDICATOR_DASHBOARD_V F
             WHERE DATA_SOURCE_NAME IN (SELECT DATA_SOURCE_NAME     
			                            FROM ???.DIM_DASH_VIZ_METRIC_XREF_V 
                                        WHERE SEMANTIC_VIEW_NAME = 'F_IND_DASH_MACROECONOMICS_VIZ_V'
						            )
            ) MAXDT ON 1=1
            WHERE F.DATE_KEY BETWEEN CAST(CONCAT(TRIM(EXTRACT(YEAR FROM MAX_DT)-1),'-01-01') AS DATE FORMAT 'YYYY-MM-DD') AND MAX_DT AND  
			      UPPER(F.DATE_GRANULARITY) = 'MONTHLY'
                      				
        UNION ALL
        
		SELECT 
		    DATE_KEY,
            DATE_KEY - EXTRACT(DAY FROM DATE_KEY)+1 AS MONTH_KEY,
            DENSE_RANK() OVER (PARTITION BY EXTRACT(YEAR FROM DATE_KEY) ORDER BY DATE_KEY ASC) AS WEEK_NUM,
            UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
            G.COUNTY,
            G.STATE_CODE,
            G.STATE_NAME,
            G.COUNTRY_NAME,
            G.POPULATION,
            MT.METRIC_DISPLAY_NAME AS METRIC_NAME,
            MT.METRIC_DISPLAY_SHORT_NAME,
		    MT.METRIC_UOM,
            MT.DASH_VIZ_DISPLAY_NAME,
            CASE WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'I' 
			     THEN F.METRIC_INDEX
                 WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'V' 
			     THEN F.METRIC_VALUE
            END AS METRIC_VALUE,
            F.DATA_SOURCE_NAME    
        FROM ???.FACT_INDICATOR_DASHBOARD_V F
             JOIN ???.DIM_DASH_VIZ_METRIC_XREF_V MT  ON 
                  MT.SEMANTIC_VIEW_NAME             = 'F_IND_DASH_MACROECONOMICS_VIZ_V' AND
                  F.METRIC_NAME                     = MT.METRIC_NAME AND 
                  F.DATA_SOURCE_NAME                = MT.DATA_SOURCE_NAME  AND
                  DECODE(F.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_1_NAME,'?')) = DECODE(MT.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_1_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_2_NAME,'?')) = DECODE(MT.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_2_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_3_NAME,'?')) = DECODE(MT.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_3_NAME,'?'))
            JOIN ???.DIM_GEO_LOCATION_V G ON 
                  F.GEO_KEY = G.UID
            LEFT JOIN 
			(
             SELECT    
			 MAX(DATE_KEY) MAX_DT
             FROM ???.FACT_INDICATOR_DASHBOARD_V F
             WHERE DATA_SOURCE_NAME IN (SELECT DATA_SOURCE_NAME     
			                            FROM ???.DIM_DASH_VIZ_METRIC_XREF_V 
                                        WHERE SEMANTIC_VIEW_NAME = 'F_IND_DASH_MACROECONOMICS_VIZ_V'
						            )
            ) MAXDT ON 1=1
            WHERE F.DATE_KEY BETWEEN CAST(CONCAT(TRIM(EXTRACT(YEAR FROM MAX_DT)-1),'-01-01') AS DATE FORMAT 'YYYY-MM-DD') AND MAX_DT AND  
			      UPPER(F.DATE_GRANULARITY) = 'WEEKLY'
                				
        ) FT
		JOIN
	    (
         SELECT   
            MAX(DATE_KEY - EXTRACT(DAY FROM DATE_KEY)) AS SNAPSHOT_DATE,
            CONCAT('M',TRIM(MONTH(MAX(DATE_KEY - EXTRACT(DAY FROM DATE_KEY)))),'-',TRIM(YEAR(MAX(DATE_KEY - EXTRACT(DAY FROM DATE_KEY))))) AS SNAPSHOT_MONTH
         FROM ???.FACT_INDICATOR_DASHBOARD_V F                    
         WHERE DATA_SOURCE_NAME IN (SELECT DATA_SOURCE_NAME     
			                        FROM ???.DIM_DASH_VIZ_METRIC_XREF_V 
                                    WHERE SEMANTIC_VIEW_NAME = 'F_IND_DASH_MACROECONOMICS_VIZ_V'
								   )
        ) DT ON 
        1=1;
		

REPLACE VIEW ???.F_IND_DASH_MACROECONOMICS_VIZ_V AS
    LOCKING ROW FOR ACCESS
    SELECT 
        DT.SNAPSHOT_DATE,
        DT.SNAPSHOT_MONTH,
        FT.DATE_KEY,
        FT.CURR_PREV_FLAG,
        FT.GEO_GRANULARITY,
        FT.COUNTY,
        FT.STATE_CODE,
        FT.STATE_NAME,
        FT.COUNTRY_NAME,
        FT.POPULATION,
        FT.METRIC_NAME,
        FT.METRIC_DISPLAY_SHORT_NAME,
		FT.METRIC_UOM,
		FT.DASH_VIZ_DISPLAY_NAME,
        FT.METRIC_VALUE
    FROM
       (
        SELECT 
            T.DATE_KEY,
            CASE WHEN RANK() OVER (PARTITION BY T.METRIC_DISPLAY_NAME ORDER BY DATE_KEY DESC) = 1
                 THEN 'CURR-CY'
                 WHEN RANK() OVER (PARTITION BY T.METRIC_DISPLAY_NAME ORDER BY DATE_KEY DESC) = 2
                 THEN 'PREV-CY'
                 WHEN RANK() OVER (PARTITION BY T.METRIC_DISPLAY_NAME ORDER BY DATE_KEY DESC) = 13
                 THEN 'CURR-LY'
            END CURR_PREV_FLAG,
            T.GEO_GRANULARITY,
            T.COUNTY,
            T.STATE_CODE,
            T.STATE_NAME,
            T.COUNTRY_NAME,
            T.POPULATION,
            T.METRIC_DISPLAY_NAME AS METRIC_NAME,
            T.METRIC_DISPLAY_SHORT_NAME,
			T.METRIC_UOM,
			T.DASH_VIZ_DISPLAY_NAME,
            T.METRIC_VALUE,
            T.DATA_SOURCE_NAME
        FROM
           (
            SELECT 
			    DATE_KEY,
                UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
                G.COUNTY,
                G.STATE_CODE,
                G.STATE_NAME,
                G.COUNTRY_NAME,
                G.POPULATION,
                MT.METRIC_DISPLAY_NAME,
                MT.METRIC_DISPLAY_SHORT_NAME,
				MT.METRIC_UOM,
                MT.DASH_VIZ_DISPLAY_NAME,                
                CASE WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'I' 
				     THEN F.METRIC_INDEX
                     WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'V' 
					 THEN F.METRIC_VALUE
                END AS METRIC_VALUE,
                F.DATA_SOURCE_NAME
            FROM ???.FACT_INDICATOR_DASHBOARD_V F 
                 JOIN ???.DIM_DASH_VIZ_METRIC_XREF_V MT  ON 
                      MT.SEMANTIC_VIEW_NAME             = 'F_IND_DASH_MACROECONOMICS_VIZ_V' AND
                      F.METRIC_NAME                     = MT.METRIC_NAME AND 
                      F.DATA_SOURCE_NAME                = MT.DATA_SOURCE_NAME  AND
                      DECODE(F.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_1_NAME,'?')) = DECODE(MT.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_1_NAME,'?')) AND
                      DECODE(F.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_2_NAME,'?')) = DECODE(MT.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_2_NAME,'?')) AND
                      DECODE(F.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_3_NAME,'?')) = DECODE(MT.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_3_NAME,'?'))
                JOIN ???.DIM_GEO_LOCATION_V G ON 
                     F.GEO_KEY = G.UID
                LEFT JOIN 
			    (
                 SELECT    
				    MAX(DATE_KEY) MAX_DT
                 FROM ???.FACT_INDICATOR_DASHBOARD_V F
                 WHERE DATA_SOURCE_NAME IN (SELECT DATA_SOURCE_NAME     
				                            FROM ???.DIM_DASH_VIZ_METRIC_XREF_V 
                                            WHERE SEMANTIC_VIEW_NAME = 'F_IND_DASH_MACROECONOMICS_VIZ_V'
										   )
                ) MAXDT ON 1=1
            WHERE F.DATE_KEY BETWEEN ADD_MONTHS(MAX_DT,-20) AND MAX_DT AND  
			      UPPER(F.DATE_GRANULARITY) = 'MONTHLY'

           ) T
        QUALIFY RANK() OVER (PARTITION BY T.METRIC_DISPLAY_NAME ORDER BY T.DATE_KEY DESC) IN (1,2,13)
                                                                                                        				
        UNION ALL
		
        SELECT 
            DATE_KEY,
            'JAN-CY' AS CURR_PREV_FLAG,
            UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
            G.COUNTY,
            G.STATE_CODE,
            G.STATE_NAME,
            G.COUNTRY_NAME,
            G.POPULATION,
            MT.METRIC_DISPLAY_NAME AS METRIC_NAME,
            MT.METRIC_DISPLAY_SHORT_NAME,
			MT.METRIC_UOM,
            MT.DASH_VIZ_DISPLAY_NAME,  
            CASE WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'I' 
			     THEN F.METRIC_INDEX
                 WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'V' 
			     THEN F.METRIC_VALUE
            END AS METRIC_VALUE,
            F.DATA_SOURCE_NAME
        FROM ???.FACT_INDICATOR_DASHBOARD_V F
             JOIN ???.DIM_DASH_VIZ_METRIC_XREF_V MT  ON 
                  MT.SEMANTIC_VIEW_NAME             = 'F_IND_DASH_MACROECONOMICS_VIZ_V' AND
                  F.METRIC_NAME                     = MT.METRIC_NAME AND 
                  F.DATA_SOURCE_NAME                = MT.DATA_SOURCE_NAME  AND
                  DECODE(F.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_1_NAME,'?')) = DECODE(MT.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_1_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_2_NAME,'?')) = DECODE(MT.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_2_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_3_NAME,'?')) = DECODE(MT.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_3_NAME,'?'))
             JOIN ???.DIM_GEO_LOCATION_V G ON 
             F.GEO_KEY = G.UID
             LEFT JOIN 
			 (
              SELECT    
			  MAX(DATE_KEY) MAX_DT
              FROM ???.FACT_INDICATOR_DASHBOARD_V F
              WHERE DATA_SOURCE_NAME IN (SELECT DATA_SOURCE_NAME     
			                             FROM ???.DIM_DASH_VIZ_METRIC_XREF_V 
                                         WHERE SEMANTIC_VIEW_NAME = 'F_IND_DASH_MACROECONOMICS_VIZ_V'
							   )
             ) MAXDT ON 1=1
            WHERE MONTH( F.DATE_KEY) = 1 AND  
			      YEAR(F.DATE_KEY) = YEAR (MAX_DT) AND  
				  UPPER(F.DATE_GRANULARITY) = 'MONTHLY'

        UNION ALL
        
		SELECT 
            T.DATE_KEY AS DATE_KEY,
            CASE WHEN RANK() OVER (PARTITION BY T.METRIC_DISPLAY_NAME ORDER BY DATE_KEY DESC) = 1
                 THEN 'CURR-CY'
                 WHEN RANK() OVER (PARTITION BY T.METRIC_DISPLAY_NAME ORDER BY DATE_KEY DESC) = 2
                 THEN 'PREV-CY'
                 WHEN RANK() OVER (PARTITION BY T.METRIC_DISPLAY_NAME ORDER BY DATE_KEY DESC) = 13
                 THEN 'CURR-LY'
            END CURR_PREV_FLAG,
            T.GEO_GRANULARITY,
            T.COUNTY,
            T.STATE_CODE,
            T.STATE_NAME,
            T.COUNTRY_NAME,
            T.POPULATION,
            T.METRIC_DISPLAY_NAME AS METRIC_NAME,
            T.METRIC_DISPLAY_SHORT_NAME,
			T.METRIC_UOM,
			T.DASH_VIZ_DISPLAY_NAME,
            T.METRIC_VALUE,
            T.DATA_SOURCE_NAME
        FROM
           (
            SELECT 
			    DATE_KEY,
                ADD_MONTHS(DATE_KEY - EXTRACT(DAY FROM DATE_KEY)+1,1)-1 AS MONTH_KEY,
                UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
                G.COUNTY,
                G.STATE_CODE,
                G.STATE_NAME,
                G.COUNTRY_NAME,
                G.POPULATION,
                MT.METRIC_DISPLAY_NAME,
                MT.METRIC_DISPLAY_SHORT_NAME,
				MT.METRIC_UOM,
                MT.DASH_VIZ_DISPLAY_NAME,                
                CASE WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'I' 
				     THEN F.METRIC_INDEX
                     WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'V' 
					 THEN F.METRIC_VALUE
                END AS METRIC_VALUE,
                F.DATA_SOURCE_NAME
            FROM ???.FACT_INDICATOR_DASHBOARD_V F
             JOIN ???.DIM_DASH_VIZ_METRIC_XREF_V MT  ON 
                  MT.SEMANTIC_VIEW_NAME             = 'F_IND_DASH_MACROECONOMICS_VIZ_V' AND
                  F.METRIC_NAME                     = MT.METRIC_NAME AND 
                  F.DATA_SOURCE_NAME                = MT.DATA_SOURCE_NAME  AND
                  DECODE(F.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_1_NAME,'?')) = DECODE(MT.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_1_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_2_NAME,'?')) = DECODE(MT.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_2_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_3_NAME,'?')) = DECODE(MT.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_3_NAME,'?'))
             JOIN ???.DIM_GEO_LOCATION_V G ON 
             F.GEO_KEY = G.UID
             LEFT JOIN 
			 (
              SELECT    
			  MAX(DATE_KEY) MAX_DT
              FROM ???.FACT_INDICATOR_DASHBOARD_V F
              WHERE DATA_SOURCE_NAME IN (SELECT DATA_SOURCE_NAME     
			                             FROM ???.DIM_DASH_VIZ_METRIC_XREF_V 
                                         WHERE SEMANTIC_VIEW_NAME = 'F_IND_DASH_MACROECONOMICS_VIZ_V'
							            )
             ) MAXDT ON 1=1
            WHERE F.DATE_KEY BETWEEN ADD_MONTHS(MAX_DT,-20) AND ADD_MONTHS(MAX_DT,0) AND      -- US-EIA had -20 to -1 and not 0
			      UPPER(F.DATE_GRANULARITY) = 'WEEKLY'
            QUALIFY RANK() OVER (PARTITION BY METRIC_DISPLAY_NAME,MONTH_KEY ORDER BY DATE_KEY DESC) = 1
           ) T
        QUALIFY RANK() OVER (PARTITION BY T.METRIC_DISPLAY_NAME ORDER BY DATE_KEY DESC) IN (1,2,13)
                                                                                                        
        UNION ALL
		
        SELECT 
            T.DATE_KEY AS DATE_KEY,
            T.CURR_PREV_FLAG,
            T.GEO_GRANULARITY,
            T.COUNTY,
            T.STATE_CODE,
            T.STATE_NAME,
            T.COUNTRY_NAME,
            T.POPULATION,
            T.METRIC_DISPLAY_NAME AS METRIC_NAME,
            T.METRIC_DISPLAY_SHORT_NAME,
			T.METRIC_UOM,
			T.DASH_VIZ_DISPLAY_NAME,
            T.METRIC_VALUE,
            T.DATA_SOURCE_NAME
        FROM
           (
            SELECT 
			    DATE_KEY,
                ADD_MONTHS(DATE_KEY - EXTRACT(DAY FROM DATE_KEY)+1,1)-1 AS MONTH_KEY,
                'JAN-CY' AS CURR_PREV_FLAG,
                UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
                G.COUNTY,
                G.STATE_CODE,
                G.STATE_NAME,
                G.COUNTRY_NAME,
                G.POPULATION,
                MT.METRIC_DISPLAY_NAME,
                MT.METRIC_DISPLAY_SHORT_NAME,
			    MT.METRIC_UOM,
                MT.DASH_VIZ_DISPLAY_NAME,  
                CASE WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'I' 
			         THEN F.METRIC_INDEX
                     WHEN UPPER(MT.METRIC_VAL_IND_SEL) = 'V' 
			         THEN F.METRIC_VALUE
                END AS METRIC_VALUE,
                F.DATA_SOURCE_NAME
            FROM ???.FACT_INDICATOR_DASHBOARD_V F
             JOIN ???.DIM_DASH_VIZ_METRIC_XREF_V MT  ON 
                  MT.SEMANTIC_VIEW_NAME             = 'F_IND_DASH_MACROECONOMICS_VIZ_V' AND
                  F.METRIC_NAME                     = MT.METRIC_NAME AND 
                  F.DATA_SOURCE_NAME                = MT.DATA_SOURCE_NAME  AND
                  DECODE(F.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_1_NAME,'?')) = DECODE(MT.SUBDOMAIN_1_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_1_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_2_NAME,'?')) = DECODE(MT.SUBDOMAIN_2_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_2_NAME,'?')) AND
                  DECODE(F.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(F.SUBDOMAIN_3_NAME,'?')) = DECODE(MT.SUBDOMAIN_3_NAME,'','?',' ','?',COALESCE(MT.SUBDOMAIN_3_NAME,'?'))
             JOIN ???.DIM_GEO_LOCATION_V G ON 
             F.GEO_KEY = G.UID
             LEFT JOIN 
			 (
              SELECT    
			  MAX(DATE_KEY) MAX_DT
              FROM ???.FACT_INDICATOR_DASHBOARD_V F
              WHERE DATA_SOURCE_NAME IN (SELECT DATA_SOURCE_NAME     
			                             FROM ???.DIM_DASH_VIZ_METRIC_XREF_V 
                                         WHERE SEMANTIC_VIEW_NAME = 'F_IND_DASH_MACROECONOMICS_VIZ_V'
							            )
             ) MAXDT ON 1=1
            WHERE MONTH(F.DATE_KEY) = 1 AND  
			      YEAR(DATE_KEY) = YEAR(MAX_DT) AND  
				  UPPER(F.DATE_GRANULARITY) = 'WEEKLY'
            QUALIFY RANK() OVER (PARTITION BY MT.METRIC_DISPLAY_NAME, MONTH_KEY ORDER BY DATE_KEY DESC) = 1
           ) T				
                                                                                                        				
        ) FT
        JOIN 
	    (
         SELECT   
            MAX(DATE_KEY - EXTRACT(DAY FROM DATE_KEY)) AS SNAPSHOT_DATE,
            CONCAT('M',TRIM(MONTH(MAX(DATE_KEY - EXTRACT(DAY FROM DATE_KEY)))),'-',TRIM(YEAR(MAX(DATE_KEY - EXTRACT(DAY FROM DATE_KEY))))) AS SNAPSHOT_MONTH
         FROM ???.FACT_INDICATOR_DASHBOARD_V F                    
         WHERE DATA_SOURCE_NAME IN (SELECT DATA_SOURCE_NAME     
			                        FROM ???.DIM_DASH_VIZ_METRIC_XREF_V 
                                    WHERE SEMANTIC_VIEW_NAME = 'F_IND_DASH_MACROECONOMICS_VIZ_V'
								   )
        ) DT ON 
       1=1;


REPLACE VIEW ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT_V AS
LOCKING ROW FOR ACCESS
SELECT * FROM ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT
QUALIFY RANK() OVER (PARTITION BY 1 ORDER BY SNAPSHOT_DATE DESC) = 1;


REPLACE VIEW ???.F_IND_DASH_MOBILITY_GEO_VIZ_V AS
    LOCKING ROW FOR ACCESS
    SELECT
        SNAPSHOT_DATE,
        SNAPSHOT_WEEK,
        CURR_PREV_FLAG,
        DATE_KEY,
        PEAK_CASES_DATE_KEY,
        WEEKDAY,
        WKND_WRKDY_FLAG,
        GEO_GRANULARITY,
        COUNTY,
        STATE_CODE,
        STATE_NAME,
        POPULATION,
        COUNTRY_NAME,
        
        CASE
            WHEN UPPER(GEO_GRANULARITY) = 'COUNTY' THEN COUNTY_POP_RNK ELSE NULL
        END COUNTY_POP_RNK,
            
        CASE
            WHEN UPPER(GEO_GRANULARITY) = 'COUNTRY' THEN COUNTRY_POP_RNK ELSE NULL
        END COUNTRY_POP_RNK,
            LOCATION_TYPE,
            MOBIL_PERC_CHANGE_BASELINE
        FROM
        (
        SELECT
            DT.SNAPSHOT_DATE,
            DT.SNAPSHOT_WEEK,
            
            CASE
                WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
            THEN DT.CURR_PREV_FLAG
            END AS CURR_PREV_FLAG,
                F.DATE_KEY,
                
            CASE
                WHEN GP.PEAK_FLAG = 'PEAK'
            THEN GP.DATE_KEY
            ELSE NULL
            END	AS PEAK_CASES_DATE_KEY,
                
            CASE
                WHEN DOW.CAL_DAY_OF_WEEK = 1
            THEN 'SUN'
                WHEN DOW.CAL_DAY_OF_WEEK = 2
            THEN 'MON'
                WHEN DOW.CAL_DAY_OF_WEEK = 3
            THEN 'TUE'
                WHEN DOW.CAL_DAY_OF_WEEK = 4
            THEN 'WED'
                WHEN DOW.CAL_DAY_OF_WEEK = 5
            THEN 'THU'
                WHEN DOW.CAL_DAY_OF_WEEK = 6
            THEN 'FRI'
                WHEN DOW.CAL_DAY_OF_WEEK = 7
            THEN 'SAT'
            END WEEKDAY,
                
            CASE
                WHEN DOW.CAL_DAY_OF_WEEK IN (1,7) THEN 'WEEKEND'
            ELSE 'WORKDAY'
            END WKND_WRKDY_FLAG,
                F.GEO_KEY,
                F.GEO_GRANULARITY,
                G.COUNTY,
                G.STATE_NAME,
                G.STATE_CODE,
                G.POPULATION,
                G.COUNTRY_NAME,
                DENSE_RANK() OVER (PARTITION BY SNAPSHOT_DATE,G.COUNTRY_NAME
            ORDER BY (
            CASE
                WHEN UPPER( G.GEO_GRANULARITY)='COUNTY' THEN G.POPULATION ELSE NULL
            END) DESC) AS COUNTY_POP_RNK,
                DENSE_RANK() OVER (PARTITION BY SNAPSHOT_DATE
            ORDER BY (
            CASE
                WHEN UPPER( G.GEO_GRANULARITY)='COUNTRY' THEN G.POPULATION ELSE NULL
            END) DESC) AS COUNTRY_POP_RNK,
                TRIM(OREPLACE(F.METRIC_NAME,'%Mobility_Change_Baseline for','')) AS LOCATION_TYPE,
                F.METRIC_INDEX AS MOBIL_PERC_CHANGE_BASELINE
            FROM ???.FACT_INDICATOR_DASHBOARD_V F 
            JOIN ???.DIM_GEO_LOCATION_V G ON
            F.GEO_KEY = G.UID
            JOIN (
            SELECT 
                MAX(WEEK_END_DATE) OVER () AS SNAPSHOT_DATE,
                MAX(CAL_WEEK_YEAR) OVER () AS SNAPSHOT_WEEK,
                MIN(WEEK_START_DATE) OVER () AS FIL_START_DATE_KEY,
                MAX(WEEK_END_DATE) OVER () FIL_END_DATE_KEY,
                
                CASE
                    WHEN RNK =1 THEN 'CURR'
                    WHEN RNK =2 THEN 'PREV'
                ELSE 'PREV-1'
                END CURR_PREV_FLAG,
                    RANK() OVER (
                ORDER BY WEEK_END_DATE DESC) RNK,
                    DT.*
                FROM ???.DIM_CALENDAR_V DT
                LEFT JOIN (
                SELECT   MAX(DATE_KEY) MAX_DT
                    FROM ???.FACT_INDICATOR_DASHBOARD_V F
                    WHERE F.DATA_SOURCE_NAME = 'Google Mobility Report'
                )  MAXDT ON 1=1
                WHERE CAL_DATE_KEY IN (MAX_DT-7, MAX_DT-14)
            ) DT ON
            F.DATE_KEY BETWEEN DT.FIL_START_DATE_KEY AND DT.FIL_END_DATE_KEY
            JOIN ???.DIM_CALENDAR_V DOW ON 
            F.DATE_KEY = DOW.CAL_DATE_KEY
            LEFT JOIN (
            SELECT 
                MA.GEO_KEY,
                MA.DATE_KEY,
                MA.NEW_CASES_7MAVG,
                
                CASE
                    WHEN MAX(MA.DATE_KEY) OVER (PARTITION BY MA.GEO_KEY) - MIN(MA.DATE_KEY) OVER (PARTITION BY MA.GEO_KEY) < 7
                THEN 'NO PEAK'
                    WHEN LEAD(NEW_CASES_7MAVG,1) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) <  NEW_CASES_7MAVG AND
                LEAD(NEW_CASES_7MAVG,2) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) <  LEAD(NEW_CASES_7MAVG,1) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) AND
                LEAD(NEW_CASES_7MAVG,3) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) <  LEAD(NEW_CASES_7MAVG,2) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) AND
                LEAD(NEW_CASES_7MAVG,4) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) <  LEAD(NEW_CASES_7MAVG,3) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) AND
                LEAD(NEW_CASES_7MAVG,5) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) <  LEAD(NEW_CASES_7MAVG,4) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) AND
                LEAD(NEW_CASES_7MAVG,6) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) <  LEAD(NEW_CASES_7MAVG,5) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) AND
                LEAD(NEW_CASES_7MAVG,7) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) <  LEAD(NEW_CASES_7MAVG,6) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) AND
                LEAD(NEW_CASES_7MAVG,8) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) <  LEAD(NEW_CASES_7MAVG,7) OVER  (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC)
                THEN 'PEAK'
                ELSE 'NO PEAK'
                END PEAK_FLAG
                FROM ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT_V MA
                JOIN (
                SELECT 
                    DATE_KEY,
                    GEO_KEY,
                    COUNTY,
                    STATE_NAME,
                    DENSE_RANK() OVER (PARTITION BY COUNTY, STATE_NAME
                    ORDER BY NEW_CASES_7MAVG DESC,
                        DATE_KEY ASC) AS RNK
                    FROM ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT_V
                    QUALIFY RNK=1
                ) TP ON
                MA.GEO_KEY = TP.GEO_KEY AND
                MA.DATE_KEY BETWEEN TP.DATE_KEY AND TP.DATE_KEY + 14
                QUALIFY RANK() OVER (PARTITION BY MA.GEO_KEY
                ORDER BY MA.DATE_KEY ASC) = 1
            ) GP ON
            F.GEO_KEY = GP.GEO_KEY
            WHERE F.DATA_SOURCE_NAME = 'Google Mobility Report'
        ) T
        WHERE CURR_PREV_FLAG IN ('CURR','PREV');


REPLACE VIEW ???.F_IND_DASH_MOBILITY_GEO_WEEKLY_V AS
    LOCKING ROW FOR ACCESS
    SELECT
        SNAPSHOT_DATE,
        SNAPSHOT_WEEK,
        CURR_PREV_FLAG,
        DENSE_RANK() OVER (PARTITION BY GEO_KEY, CURR_PREV_FLAG
        ORDER BY DATE_KEY ASC) CAL_DAY_OF_WEEK,
            GEO_KEY,
            GEO_GRANULARITY,
            COUNTY,
            STATE_CODE,
            STATE_NAME,
            COUNTRY_NAME,
            POPULATION,
            DATE_KEY,
            METRIC_NAME,
            METRIC_INDEX
        FROM
        (
        SELECT 
            DT.SNAPSHOT_DATE,
            DT.SNAPSHOT_WEEK,
            
            CASE
                WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
            THEN DT.CURR_PREV_FLAG
            END AS CURR_PREV_FLAG,
                F.GEO_KEY,
                UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
                G.COUNTY,
                G.STATE_CODE,
                G.STATE_NAME,
                G.COUNTRY_NAME,
                G.POPULATION,
                F.DATE_KEY,
                METRIC_NAME,
                METRIC_INDEX
            FROM ???.FACT_INDICATOR_DASHBOARD_V F 
            JOIN ???.DIM_GEO_LOCATION_V G ON
            F.GEO_KEY = G.UID
            JOIN (
            SELECT 
                MAX(WEEK_END_DATE) OVER () AS SNAPSHOT_DATE,
                MAX(CAL_WEEK_YEAR) OVER () AS SNAPSHOT_WEEK,
                MIN(WEEK_START_DATE) OVER () AS FIL_START_DATE_KEY,
                MAX(WEEK_END_DATE) OVER () FIL_END_DATE_KEY,
                
                CASE
                    WHEN RNK =1 THEN 'CURR'
                    WHEN RNK =2 THEN 'PREV'
                    WHEN RNK =3 THEN 'PREV-1'
                    WHEN RNK =4 THEN 'PREV-2'
                    WHEN RNK =4 THEN 'PREV-3'
                ELSE 'PREV-4'
                END CURR_PREV_FLAG,
                    RANK() OVER (
                ORDER BY WEEK_END_DATE DESC) RNK,
                    DT.*
                FROM ???.DIM_CALENDAR_V DT
                LEFT JOIN (
                SELECT MAX(DATE_KEY) MAX_DT
                    FROM ???.FACT_INDICATOR_DASHBOARD_V F  
                    JOIN ???.DIM_GEO_LOCATION_V G ON
                    F.GEO_KEY = G.UID
                    WHERE F.DATA_SOURCE_NAME = 'Google Mobility Report'
                ) MAXDT ON 1=1
                WHERE CAL_DATE_KEY IN (MAX_DT,MAX_DT-7,MAX_DT-14,MAX_DT-21,MAX_DT-28, MAX_DT-35)
            ) DT ON
            F.DATE_KEY BETWEEN DT.FIL_START_DATE_KEY AND DT.FIL_END_DATE_KEY
            WHERE F.DATA_SOURCE_NAME = 'Google Mobility Report'
                AND  
            CASE
                WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
            THEN DT.CURR_PREV_FLAG
            END IN ('CURR','PREV','PREV-1','PREV-2','PREV-3')
        ) T;


REPLACE VIEW ???.F_IND_DASH_Timeline_to_safety_V AS
-- Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
--08/05/2020       2.0         Teradata DW              	Changed avg(mobility_composite) to a max()                                                                     
    LOCKING ROW FOR ACCESS --    
        -- prev query is used to compare the previouly loaded projections against the latest projections
        -- this will show if the modeling is indicating things are getting better or worst.
        -- The query should be indentical to the bottom query excpet it uses the view ???.F_IND_DASH_Covid_Projections_prev_V
    WITH prev AS (
    SELECT   
        geo_key,
        STATE_NAME,
        STATE_CODE,
        Population,
        mobility_composite,
         --date_delta,
        Est_Date_start,
        NULL Est_Date_end,
        Bucket,
        (
        SELECT dt2.week_of_year
            FROM ???.DIM_CALENDAR_V dt2
            WHERE cal_date_key = Est_Date_start)   - dt.week_of_year seq_week_nbr,
        SNAPSHOT_DATE,
        SNAPSHOT_WEEK,
        CAL_WEEK_YEAR,
        WEEK_START_DATE,
        WEEK_END_DATE,
        cal_day_sat,
        day_of_year,
        day_of_cal_1900 --select *
        
        FROM (
        SELECT states.geo_key,
            states.state_name,
            states.state_code,
            states.population,
            mobility_composite,
            Est_Date_start,
            bucket
            FROM (
            SELECT DISTINCT date_key,
                geo_key,
                g.state_name,
                g.state_code,
                g.Population --,  MODELED_DATE,  est_infections_mean
                
                FROM ???.F_IND_DASH_Covid_Projections_prev_V a
                JOIN ???.DIM_GEO_LOCATION_V g ON g.uid = a.geo_key) states  
                                                                                                                                         
            JOIN (
            SELECT DISTINCT
                geo_key,
                state_name,
                safe_flag,
                1 bucket,
                MIN(Est_Date_start)  OVER(PARTITION BY geo_key) + 14 Est_Date_start,
                max(mobility_composite) OVER(PARTITION BY geo_key)  mobility_composite
                FROM (
                SELECT geo_key,
                    state_name,
                    infections_per100k,
                    mobility_composite,
                    safe_day,
                    Last_confirmed_infections,
                    
                    CASE
                        WHEN  
                    SUM(safe_day) OVER (PARTITION BY geo_key
                    ORDER BY modeled_date 
                    ROWS  BETWEEN  CURRENT ROW AND 13 FOLLOWING  ) >= 14 THEN 'Y' ELSE 'N'
                    END safe_flag,
                        
                    CASE
                        WHEN safe_flag = 'Y' THEN modeled_date ELSE NULL
                    END Est_Date_start
                    FROM (
                    SELECT   geo_key,
                        state_name,
                        f.mobility_composite,
                        f.modeled_date,
                        MAX(
                        CASE
                            WHEN f.confirmed_infections IS NOT NULL THEN f.modeled_date
                        END ) OVER(PARTITION BY geo_key) Last_confirmed_infections,
                            CAST(  est_infections_mean*(CAST(100000 AS DECIMAL(15,4)) /population) AS DECIMAL(15,4)) infections_per100k,
                            
                        CASE
                            WHEN infections_per100k <4  THEN 1 ELSE 0
                        END safe_day,
                            
                        CASE
                            WHEN infections_per100k >=4 
                        AND infections_per100k > LAG(infections_per100k,1) OVER(PARTITION BY uid
                        ORDER BY modeled_date)
                        THEN 1 ELSE 0
                        END bad_day
                        FROM ???.F_IND_DASH_Covid_Projections_prev_V F 
                        JOIN ???.DIM_GEO_LOCATION_V G ON
                        F.GEO_KEY = G.UID
                         --where f.geo_key = 84000001
                        )  a   ) final
                WHERE safe_flag = 'Y'
                    AND  COALESCE(est_date_start,Last_confirmed_infections - 13)  >= Last_confirmed_infections  - 13
                                                                                                                                     
            ) safe
            ON states.geo_key = safe.geo_key 
        UNION ALL
        SELECT states.geo_key,
            states.state_name,
            states.state_code,
            states.population,
            mobility_composite,
            Est_Date_start,
            bucket
            FROM (
            SELECT DISTINCT date_key,
                geo_key,
                g.state_name,
                g.state_code,
                g.Population --,  MODELED_DATE,  est_infections_mean
                
                FROM ???.F_IND_DASH_Covid_Projections_prev_V a
                JOIN ???.DIM_GEO_LOCATION_V g ON g.uid = a.geo_key) states  
            JOIN 
            (
            SELECT DISTINCT
                geo_key,
                state_name,
                safe_flag,
                2 bucket,
                MIN(Est_Date_start)   OVER(PARTITION BY geo_key) + 14 Est_Date_start,
                max(mobility_composite)  OVER(PARTITION BY geo_key) mobility_composite
                FROM (
                SELECT geo_key,
                    state_name,
                    infections_per100k,
                    mobility_composite,
                    safe_day,
                    Last_confirmed_infections,
                    
                    CASE
                        WHEN  
                    SUM(safe_day) OVER (PARTITION BY geo_key
                    ORDER BY modeled_date 
                    ROWS   BETWEEN  CURRENT ROW AND 13 FOLLOWING ) >= 14 THEN 'Y' ELSE 'N'
                    END safe_flag,
                        
                    CASE
                        WHEN safe_flag = 'Y' THEN modeled_date ELSE NULL
                    END Est_Date_start
                    FROM (
                    SELECT   geo_key,
                        state_name,
                        f.mobility_composite,
                        f.modeled_date,
                        MAX(
                        CASE
                            WHEN f.confirmed_infections IS NOT NULL THEN f.modeled_date
                        END ) OVER(PARTITION BY geo_key) Last_confirmed_infections,
                            CAST(  est_infections_mean*(CAST(100000 AS DECIMAL(15,4)) /population) AS DECIMAL(15,4)) infections_per100k,
                            
                        CASE
                            WHEN infections_per100k <4  THEN 1 ELSE 0
                        END safe_day,
                            
                        CASE
                            WHEN infections_per100k >=4 
                        AND infections_per100k > LAG(infections_per100k,1) OVER(PARTITION BY uid
                        ORDER BY modeled_date)
                        THEN 1 ELSE 0
                        END bad_day
                        FROM ???.F_IND_DASH_Covid_Projections_prev_V F 
                        JOIN ???.DIM_GEO_LOCATION_V G ON
                        F.GEO_KEY = G.UID
                         --where f.geo_key = 84000001
                        )  a   ) final
                WHERE safe_flag  = 'N'
                    AND  COALESCE(est_date_start,Last_confirmed_infections -13)  >= Last_confirmed_infections  - 13
                                                                                                                                    
            ) Not_safe
            ON states.geo_key = not_safe.geo_key 
        UNION ALL
        SELECT states.geo_key,
            states.state_name,
            states.state_code,
            states.population,
            mobility_composite,
            bad.Est_Date_start,
            bucket
            FROM (
            SELECT DISTINCT date_key,
                geo_key,
                g.state_name,
                g.state_code,
                g.Population --,  MODELED_DATE,  est_infections_mean
                
                FROM ???.F_IND_DASH_Covid_Projections_prev_V a
                JOIN ???.DIM_GEO_LOCATION_V g ON g.uid = a.geo_key) states  
            JOIN 
                                                                                                                                 
            (
            SELECT DISTINCT
                geo_key,
                state_name,
                bad_flag,
                3 bucket,
                MIN(Est_Date_start) OVER(PARTITION BY geo_key)  Est_Date_start,
                max(mobility_composite) OVER(PARTITION BY geo_key) mobility_composite
                FROM (
                SELECT geo_key,
                    state_name,
                    infections_per100k,
                    mobility_composite,
                    bad_day,
                    Last_confirmed_infections,
                    
                    CASE
                        WHEN infections_per100k >=4
                    AND  
                    SUM(bad_day) OVER (PARTITION BY geo_key
                    ORDER BY modeled_date 
                    ROWS  BETWEEN  CURRENT ROW AND 13 FOLLOWING     ) >= 14 THEN 'Y' ELSE 'N'
                    END bad_flag,
                        
                    CASE
                        WHEN bad_flag = 'Y' THEN modeled_date ELSE NULL
                    END Est_Date_start
                    FROM (
                    SELECT   geo_key,
                        state_name,
                        f.mobility_composite,
                        f.modeled_date,
                        MAX(
                        CASE
                            WHEN f.confirmed_infections IS NOT NULL THEN f.modeled_date
                        END ) OVER(PARTITION BY geo_key) Last_confirmed_infections,
                            CAST(  est_infections_mean*(CAST(100000 AS DECIMAL(15,4)) /population) AS DECIMAL(15,4)) infections_per100k,
                            
                        CASE
                            WHEN infections_per100k <4  THEN 1 ELSE 0
                        END safe_day,
                            
                        CASE
                            WHEN   infections_per100k > LAG(infections_per100k,1) OVER(PARTITION BY uid
                        ORDER BY modeled_date)
                        THEN 1 ELSE 0
                        END bad_day
                        FROM ???.F_IND_DASH_Covid_Projections_prev_V F 
                        JOIN ???.DIM_GEO_LOCATION_V G ON
                        F.GEO_KEY = G.UID
                         --where f.geo_key = 84000001
                        )  a   ) final
                WHERE bad_flag = 'Y'
                    AND  COALESCE(est_date_start,Last_confirmed_infections - 14)  >= Last_confirmed_infections - 14 
                                                                                                                                    
            ) bad 
                                                                                                                                            
            ON states.geo_key = bad.geo_key 
                                                                                      
                                                                                      
                                                                                           
                                                                                      
        ) for_view 
                                                                        
                                                                                      --      
        LEFT OUTER JOIN 
        (
        SELECT 
            MAX(WEEK_END_DATE) OVER () AS SNAPSHOT_DATE,
            MAX(CAL_WEEK_YEAR) OVER () AS SNAPSHOT_WEEK,
            MIN(WEEK_START_DATE) OVER () AS FIL_START_DATE_KEY,
            MAX(WEEK_END_DATE) OVER () FIL_END_DATE_KEY,
            
            CASE
                WHEN RNK =1 THEN 'CURR'
                WHEN RNK =2 THEN 'PREV'
            ELSE 'PREV-1'
            END CURR_curr_FLAG,
                RANK() OVER (
            ORDER BY WEEK_END_DATE DESC) RNK,
                DT.*
            FROM ???.DIM_CALENDAR_V DT
            LEFT JOIN (
            SELECT MAX(DATE_KEY) MAX_DT
                FROM ???.F_IND_DASH_Covid_Projections_prev_V  F                  
            ) MAXDT ON 1=1
            WHERE CAL_DATE_KEY IN (MAX_DT-7)
                                                                                
        ) dt
        ON   1=1
         -- prevent rows in bucket 2 that are in bucket 1 (mutuall exclusive      
         --        QUALIFY
         --        CASE
         --            WHEN (bucket = 2 AND LAG(bucket, 1, 0) RESPECT NULLS 
         --        OVER (PARTITION BY for_view.geo_key
         --        ORDER BY bucket) <> 1) OR bucket IN (1,3)  THEN 1 ELSE 0
         --        END = 1
        ) -- 
     --    select * from prev where geo_key = 84000038
     --================ main sql ================================================== 
    
    SELECT  prev_bucket,
        prev_est_start,
        prev_est_date_end,
        prev_snapshot_date,
        mobility_composite_curr,
        NEW_ENTRY,
        GEO_KEY,
        STATE_NAME,
        STATE_CODE,
        Population,
        mobility_composite,
        Last_confirmed_infections,
        Est_Date_start,
        Est_Date_end,
        bucket,
        seq_week_nbr,
        SNAPSHOT_DATE,
        SNAPSHOT_WEEK,
        CAL_WEEK_YEAR,
        WEEK_START_DATE,
        WEEK_END_DATE,
        cal_day_sat,
        day_of_year,
        day_of_cal_1900,
        DATE_OF_PROJECTIONS,
        PROJECTIONS_UP_UNTIL
        FROM (
        SELECT   
            (
            SELECT prev.Est_Date_start
                FROM prev
                WHERE for_view.geo_key = prev.geo_key
                    AND  bucket = 3)  prev_3_strt_dt,
            (
            SELECT prev.Est_Date_start
                FROM prev
                WHERE for_view.geo_key = prev.geo_key
                    AND  bucket = 2)  prev_2_strt_dt,
            (
            SELECT prev.Est_Date_start
                FROM prev
                WHERE for_view.geo_key = prev.geo_key
                    AND  bucket = 1)  prev_1_strt_dt,
            (
            SELECT prev.Est_Date_end
                FROM prev
                WHERE for_view.geo_key = prev.geo_key
                    AND  bucket = 3)  prev_3_end_dt,
            (
            SELECT prev.Est_Date_end
                FROM prev
                WHERE for_view.geo_key = prev.geo_key
                    AND  bucket = 2)  prev_2_end_dt,
            (
            SELECT prev.Est_Date_end
                FROM prev
                WHERE for_view.geo_key = prev.geo_key
                    AND  bucket = 1)  prev_1_end_dt,
            
            CASE
                WHEN bucket = 1   THEN
            CASE
                WHEN prev_1_strt_dt IS NOT NULL AND Est_Date_start <> prev_1_strt_dt THEN 1
            END
                WHEN bucket = 2   THEN
            CASE
                WHEN prev_2_strt_dt IS NOT NULL AND Est_Date_start <> prev_2_strt_dt THEN 2
                WHEN prev_1_strt_dt IS NOT NULL THEN 1
            END
                WHEN bucket = 3   THEN
            CASE
                WHEN prev_3_strt_dt IS NOT NULL AND Est_Date_start <> prev_3_strt_dt THEN 3
                WHEN prev_1_strt_dt IS NOT NULL THEN 1
            END
            END  prev_bucket,
                
            CASE
                WHEN prev_bucket = 1 THEN  prev_1_strt_dt
                WHEN prev_bucket = 2 THEN  prev_2_strt_dt
                WHEN prev_bucket = 3 THEN  prev_3_strt_dt
            ELSE NULL
            END prev_est_start,
                
            CASE
                WHEN prev_bucket = 1 THEN  prev_1_end_dt
                WHEN prev_bucket = 2 THEN  prev_2_end_dt
                WHEN prev_bucket = 3 THEN  prev_3_end_dt
            ELSE NULL
            END prev_est_date_end,
                (
            SELECT prev.snapshot_date
                FROM prev
                WHERE for_view.geo_key = prev.geo_key
                    AND  bucket = prev_bucket) prev_snapshot_date,
                mobility_composite  mobility_composite_curr,
                NULL   NEW_ENTRY,
                geo_key,
                STATE_NAME,
                STATE_CODE,
                Population,
                mobility_composite,
                 --date_delta,
            Est_Date_start,
                Last_confirmed_infections,
                NULL Est_Date_end,
                Bucket,
                (
            SELECT dt2.week_of_year
                FROM ???.DIM_CALENDAR_V dt2
                WHERE cal_date_key = Est_Date_start)   - dt.week_of_year seq_week_nbr,
                SNAPSHOT_DATE,
                SNAPSHOT_WEEK,
                CAL_WEEK_YEAR,
                WEEK_START_DATE,
                WEEK_END_DATE,
                cal_day_sat,
                day_of_year,
                day_of_cal_1900,
                Last_confirmed_infections + 1 DATE_OF_PROJECTIONS,
                (
            SELECT MAX(modeled_date)
                FROM ???.F_IND_DASH_Covid_Projections_Curr_V)  PROJECTIONS_UP_UNTIL --select *
             --select *       
            
            FROM (
            SELECT states.geo_key,
                states.state_name,
                states.state_code,
                states.population,
                mobility_composite,
                Est_Date_start,
                bucket,
                Last_confirmed_infections
                FROM (
                SELECT DISTINCT date_key,
                    geo_key,
                    g.state_name,
                    g.state_code,
                    g.Population --,  MODELED_DATE,  est_infections_mean
                    
                    FROM ???.F_IND_DASH_Covid_Projections_curr_V a
                    JOIN ???.DIM_GEO_LOCATION_V g ON g.uid = a.geo_key) states  
                                                                                                                                                         
                JOIN (
                SELECT distinct
                    geo_key,
                    state_name,
                    safe_flag,
                    1 bucket,
                    Last_confirmed_infections, 
                    MIN(Est_Date_start)  OVER(PARTITION BY geo_key) + 14  Est_Date_start,
                    max(mobility_composite) OVER(PARTITION BY geo_key)  mobility_composite 
                    FROM (
                    SELECT geo_key,
                        state_name,
                        infections_per100k,
                        mobility_composite,
                        safe_day,
                        Last_confirmed_infections,
                        modeled_date,
                        CASE
                            WHEN  
                        SUM(safe_day) OVER (PARTITION BY geo_key
                        ORDER BY modeled_date 
                        ROWS  BETWEEN  CURRENT ROW AND 13 FOLLOWING ) >= 14 THEN 'Y' ELSE 'N'
                        END safe_flag,
                            
                        CASE
                            WHEN safe_flag = 'Y' THEN modeled_date ELSE NULL
                        END Est_Date_start
                        FROM (
                        SELECT   geo_key,
                            state_name,
                            f.mobility_composite,
                            f.modeled_date,
                            MAX(
                            CASE
                                WHEN f.confirmed_infections IS NOT NULL THEN f.modeled_date
                            END ) OVER() Last_confirmed_infections,
                                CAST(  est_infections_mean*(CAST(100000 AS DECIMAL(15,4)) /population) AS DECIMAL(15,4)) infections_per100k,
                                
                            CASE
                                WHEN infections_per100k <4  THEN 1 ELSE 0
                            END safe_day,
                                
                            CASE
                                WHEN   infections_per100k > LAG(infections_per100k,1) OVER(PARTITION BY uid
                            ORDER BY modeled_date)
                            THEN 1 ELSE 0
                            END bad_day
                            FROM ???.F_IND_DASH_Covid_Projections_curr_V F 
                            JOIN ???.DIM_GEO_LOCATION_V G ON
                            F.GEO_KEY = G.UID
                           -- where f.geo_key = 84000001
                            )  a   ) final
                    WHERE safe_flag = 'Y'
                        AND  est_date_start > Last_confirmed_infections - 13
                                                                                                                                                     
                ) safe
                ON states.geo_key = safe.geo_key 
            UNION ALL
            SELECT states.geo_key,
                states.state_name,
                states.state_code,
                states.population,
                mobility_composite,
                Est_Date_start,
                bucket,
                Last_confirmed_infections
                FROM (
                SELECT DISTINCT date_key,
                    geo_key,
                    g.state_name,
                    g.state_code,
                    g.Population --,  MODELED_DATE,  est_infections_mean
                    
                    FROM ???.F_IND_DASH_Covid_Projections_curr_V a
                    JOIN ???.DIM_GEO_LOCATION_V g ON g.uid = a.geo_key) states  
                JOIN 
                (
                SELECT DISTINCT
                    geo_key,
                    state_name,
                    safe_flag,
                    2 bucket,
                    Last_confirmed_infections,
                    MIN(Est_Date_start)   OVER(PARTITION BY geo_key) + 14 Est_Date_start,
                    max(mobility_composite)  OVER(PARTITION BY geo_key) mobility_composite
                    FROM (
                    SELECT geo_key,
                        state_name,
                        infections_per100k,
                        mobility_composite,
                        safe_day,
                        Last_confirmed_infections,
                        
                        CASE
                            WHEN  
                        SUM(safe_day) OVER (PARTITION BY geo_key
                        ORDER BY modeled_date 
                        ROWS   BETWEEN  CURRENT ROW AND 13 FOLLOWING  ) >= 14 THEN 'Y' ELSE 'N'
                        END safe_flag,
                            
                        CASE
                            WHEN safe_flag = 'Y' THEN modeled_date ELSE NULL
                        END Est_Date_start
                        FROM (
                        SELECT   geo_key,
                            state_name,
                            f.mobility_composite,
                            f.modeled_date,
                            MAX(
                            CASE
                                WHEN f.confirmed_infections IS NOT NULL THEN f.modeled_date
                            END ) OVER() Last_confirmed_infections,
                                CAST(  est_infections_mean*(CAST(100000 AS DECIMAL(15,4)) /population) AS DECIMAL(15,4)) infections_per100k,
                                
                            CASE
                                WHEN infections_per100k <4  THEN 1 ELSE 0
                            END safe_day,
                                
                            CASE
                                WHEN   infections_per100k > LAG(infections_per100k,1) OVER(PARTITION BY uid
                            ORDER BY modeled_date)
                            THEN 1 ELSE 0
                            END bad_day
                            FROM ???.F_IND_DASH_Covid_Projections_curr_V F 
                            JOIN ???.DIM_GEO_LOCATION_V G ON
                            F.GEO_KEY = G.UID
                             --where f.geo_key = 84000002
                            )  a   ) final
                    WHERE safe_flag = 'N'
                        AND  COALESCE(est_date_start,Last_confirmed_infections -13)  >= Last_confirmed_infections  - 13
                                                                                                                                                    
                ) Not_safe
                ON states.geo_key = not_safe.geo_key 
            UNION ALL
            SELECT states.geo_key,
                states.state_name,
                states.state_code,
                states.population,
                mobility_composite,
                bad.Est_Date_start,
                bucket,
                Last_confirmed_infections
                FROM (
                SELECT DISTINCT date_key,
                    geo_key,
                    g.state_name,
                    g.state_code,
                    g.Population --,  MODELED_DATE,  est_infections_mean
                    
                    FROM ???.F_IND_DASH_Covid_Projections_curr_V a
                    JOIN ???.DIM_GEO_LOCATION_V g ON g.uid = a.geo_key) states  
                JOIN 
                                                                                                                                                 
                (
                SELECT DISTINCT
                    geo_key,
                    state_name,
                    bad_flag,
                    3 bucket,
                    Last_confirmed_infections,
                    MIN(Est_Date_start) OVER(PARTITION BY geo_key)  Est_Date_start,
                    max(mobility_composite) OVER(PARTITION BY geo_key) mobility_composite
                    FROM (
                    SELECT geo_key,
                        state_name,
                        infections_per100k,
                        mobility_composite,
                        bad_day,
                        Last_confirmed_infections,
                        
                        CASE
                            WHEN infections_per100k >=4
                        AND  
                        SUM(bad_day) OVER (PARTITION BY geo_key
                        ORDER BY modeled_date 
                        ROWS   BETWEEN  CURRENT ROW AND 13 FOLLOWING    ) >= 14 THEN 'Y' ELSE 'N'
                        END bad_flag,
                            
                        CASE
                            WHEN bad_flag = 'Y' THEN modeled_date ELSE NULL
                        END Est_Date_start
                        FROM (
                        SELECT   geo_key,
                            state_name,
                            f.mobility_composite,
                            f.modeled_date,
                            MAX(
                            CASE
                                WHEN f.confirmed_infections IS NOT NULL THEN f.modeled_date
                            END ) OVER() Last_confirmed_infections,
                                CAST(  est_infections_mean*(CAST(100000 AS DECIMAL(15,4)) /population) AS DECIMAL(15,4)) infections_per100k,
                                
                            CASE
                                WHEN infections_per100k <4  THEN 1 ELSE 0
                            END safe_day,
                                
                            CASE
                                WHEN
                            infections_per100k > LAG(infections_per100k,1) OVER(PARTITION BY uid
                            ORDER BY modeled_date)
                            THEN 1 ELSE 0
                            END bad_day
                            FROM ???.F_IND_DASH_Covid_Projections_curr_V F 
                            JOIN ???.DIM_GEO_LOCATION_V G ON
                            F.GEO_KEY = G.UID
                             --  where f.geo_key = 84000002
                            )  a   ) final
                    WHERE bad_flag = 'Y'
                        AND  est_date_start > Last_confirmed_infections   - 14 
                                                                                                                                                    
                ) bad 
                                                                                                                                                            
                ON states.geo_key = bad.geo_key 
                                                                                                      
                                                                                                      
                                                                                                           
                                                                                                      
            ) for_view 
                                                                                        
                                                                                                      --      
            LEFT OUTER JOIN 
            (
            SELECT 
                MAX(WEEK_END_DATE) OVER () AS SNAPSHOT_DATE,
                MAX(CAL_WEEK_YEAR) OVER () AS SNAPSHOT_WEEK,
                MIN(WEEK_START_DATE) OVER () AS FIL_START_DATE_KEY,
                MAX(WEEK_END_DATE) OVER () FIL_END_DATE_KEY,
                
                CASE
                    WHEN RNK =1 THEN 'CURR'
                    WHEN RNK =2 THEN 'PREV'
                ELSE 'PREV-1'
                END CURR_curr_FLAG,
                    RANK() OVER (
                ORDER BY WEEK_END_DATE DESC) RNK,
                    DT.*
                FROM ???.DIM_CALENDAR_V DT
                LEFT JOIN (
                SELECT MAX(DATE_KEY) MAX_DT
                    FROM ???.F_IND_DASH_Covid_Projections_curr_V  F                  
                ) MAXDT ON 1=1
                WHERE CAL_DATE_KEY IN (MAX_DT-7)
                                                                                                
            ) dt
            ON   1=1
                                                       -- where geo_key = 84000038
                                                          -- prevent rows in bucket 2 that are in bucket 1 (mutuall exclusive      
            QUALIFY
            CASE
                WHEN (bucket = 2 AND LAG(bucket, 1, 0) RESPECT NULLS 
            OVER (PARTITION BY for_view.geo_key
            ORDER BY bucket) <> 1) OR bucket IN (1,3)  THEN 1 ELSE 0
            END = 1
        ) final;

REPLACE VIEW ???.F_IND_DASH_NYT_COVID19_DATAHUB_TD_EMP_LOC_V AS 
    LOCKING ROW FOR ACCESS
    SELECT 
        H.SNAPSHOT_DATE,
        H.SNAPSHOT_WEEK,
        H.CURR_PREV_FLAG,
        HW.DATE_KEY,
        H.GEO_KEY,
        H.COUNTY,
        LKP.MSA_NAME,
        H.STATE_CODE,
        H.STATE_NAME,
        HW.COUNTRY_NAME,
        H.COUNTY_POPULATION,
        H.COUNTY_POP_RNK,
        H.CASES_TODATE_PER100K,
        H.CASES_TODATE_WK,
        H.NEW_CASES_WK,
        H.NEW_CASES_7MAVG,
        H.NEW_CASES_7MAVG_100K,
        H.DEATHS_TODATE_WK,
        H.NEW_DEATHS_WK,
        H.NEW_DEATHS_7MAVG,
        H.NEW_DEATHS_7MAVG_100K,
        H.RECOVERY_FLAG,
        H.SAFE_FLAG,
        H.SURGE_FLAG,
        
        CASE
            WHEN RANK() OVER (PARTITION BY H.SNAPSHOT_DATE, H.STATE_CODE
        ORDER BY H.GEO_KEY) = 1
        THEN DM.BUCKET
        ELSE NULL
        END AS STATE_TTS_BUCKET,
            
        CASE
            WHEN RANK() OVER (PARTITION BY H.SNAPSHOT_DATE, H.STATE_CODE
        ORDER BY H.GEO_KEY) = 1
        THEN DM.EST_DATE_START 
        ELSE NULL
        END AS STATE_TTS_EST_START_DATE,
            
        CASE
            WHEN RANK() OVER (PARTITION BY H.SNAPSHOT_DATE, H.STATE_CODE
        ORDER BY H.GEO_KEY) = 1
        THEN ICU.PEAK_ICU_BED_DAY_MEAN 
        ELSE NULL
        END AS STATE_PEAK_ICU_BEDS_MEAN_DATE,
            DH.TESTED_CNT,
            DH.CONFIRMED_CNT,
            DH.RECOVERED_CNT,
            DH.DEATH_CNT,
            DH.HOSPITALIZED_CNT,
            DH.ON_VENTILATOR_CNT,
            DH.IN_ICU_CNT,
            DH.SEVERE_CASE_CNT,
            DH.SCHOOL_CLOSING,
            DH.WORKPLACE_CLOSING,
            DH.CANCEL_EVENTS,
            DH.GATHERINGS_RESTRICTIONS,
            DH.TRANSPORT_CLOSING,
            DH.STAY_HOME_RESTRICTIONS,
            DH.INTERNAL_MOVEMENT_RESTRICTIONS,
            DH.INTERNATIONAL_MOVEMENT_RESTRICTIONS,
            DH.INFORMATION_CAMPAIGNS,
            DH.TESTING_POLICY,
            DH.CONTACT_TRACING,
            DH.STRINGENCY_INDEX,
            (
        CASE
            WHEN COALESCE(TRIM(SMSA.MSA_WITH_SITE),'') = '' THEN 0 ELSE 1
        END) MSA_WITH_SITE_FLAG,
            SA.SITE_ID            AS SITE_ID,
            SA.SITE_TYPE          AS SITE_TYPE,
            SA.ADDRESS            AS SITE_ADDRESS,
            INITCAP(LOWER(SA.CITY)) AS SITE_CITY_NAME,
            SA.MSA_NAME           AS SITE_MSA_NAME,
            SA.COUNTY_NAME        AS SITE_COUNTY_NAME,
            SA.STATE_NAME         AS SITE_STATE_NAME,
            SA.FTE_HC_AT_LOCATION AS SITE_FTE_CNT,
            SA.CONTINGENT_HC_AT_LOCATION AS SITE_NONFTE_CNT,
            SA.AVERAGE_ATTENDANCE AS SITE_AVG_ATTENDANCE,
            SA.SECURITY_TYPE      AS SITE_SECURITY_TYPE,
            (
        CASE
            WHEN COALESCE(TRIM(EMSA.MSA_WITH_EMP),'') = '' THEN 0 ELSE 1
        END) MSA_WITH_EMP_FLAG,
            PL.MSA_NAME           AS EMP_MSA_NAME,
            PL.COUNTY_NAME        AS EMP_COUNTY_NAME,
            PL.STATE_NAME         AS EMP_LOC_STATE_NAME,
            SUM(
        CASE
            WHEN UPPER(PEOPLE_TYPE) = 'VIRTUAL' THEN COALESCE(NBR_AT_LOCATION,0) ELSE 0
        END) AS LOC_VIRTUAL_EMP_CNT,
            SUM(
        CASE
            WHEN UPPER(PEOPLE_TYPE) = 'OFFICE'  THEN COALESCE(NBR_AT_LOCATION,0) ELSE 0
        END) AS LOC_OFFICE_EMP_CNT
        FROM ???.F_IND_DASH_HEALTH_VIZ_V H
        JOIN ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT_V HW ON 
        H.SNAPSHOT_DATE    = HW.SNAPSHOT_DATE  AND
        H.CURR_PREV_FLAG   = HW.CURR_PREV_FLAG AND 
        H.GEO_KEY          = HW.GEO_KEY        AND
        HW.CAL_DAY_OF_WEEK = 7
        LEFT JOIN ???.FACT_COVID19_DATAHUB_V DH ON
        HW.DATE_KEY        = DH.DATE_KEY AND 
        HW.GEO_KEY         = DH.GEO_KEY
        LEFT JOIN (
        SELECT STATE_NAME,
            COUNTY_NAME,
            MSA_NAME
            FROM ???.DIM_ZIPCODE_COUNTY_MSA_LKUP_V
            GROUP BY 1,
                2,
                3) LKP ON
        H.COUNTY           = LKP.COUNTY_NAME AND
        H.STATE_NAME       = LKP.STATE_NAME
        LEFT JOIN ???.DIM_SITE_ADDRESSES_V SA ON
        H.COUNTY              = SA.COUNTY_NAME AND
        H.STATE_NAME          = SA.STATE_NAME AND
        UPPER(SA.CLIENT_NAME) = 'TERADATA' AND
        SA.COUNTRY_CD         = 'USA'
        LEFT JOIN (
        SELECT MSA_NAME AS MSA_WITH_SITE
            FROM ???.DIM_SITE_ADDRESSES_V
            WHERE UPPER( CLIENT_NAME) = 'TERADATA'
                AND  COUNTRY_CD         = 'USA'
            GROUP BY 1
        ) SMSA ON 
        LKP.MSA_NAME = SMSA.MSA_WITH_SITE
        LEFT JOIN ???.DIM_PEOPLE_LOCATION_V PL ON
        H.COUNTY     = PL.COUNTY_NAME AND
        H.STATE_NAME = PL.STATE_NAME
        LEFT JOIN (
        SELECT MSA_NAME AS MSA_WITH_EMP
            FROM ???.DIM_PEOPLE_LOCATION_V
            GROUP BY 1
        ) EMSA ON 
        LKP.MSA_NAME = EMSA.MSA_WITH_EMP
        LEFT JOIN ???.F_IND_DASH_TIMELINE_TO_SAFETY_V DM ON 
        /*H.SNAPSHOT_DATE   = DM.SNAPSHOT_DATE AND data may lag so can't use this for join*/
        H.STATE_CODE      = DM.STATE_CODE AND
        DM.BUCKET         = 1
        LEFT JOIN ???.FACT_COVID_MODEL_DATA_SUM_V ICU ON 
        H.STATE_CODE        = ICU.STATE_CODE AND
        ICU.GEO_GRANULARITY = 'STATE'
        WHERE H.CURR_PREV_FLAG = 'CURR' --and H.state_name = 'Iowa'
        
        GROUP BY H.SNAPSHOT_DATE,
            H.SNAPSHOT_WEEK,
            H.CURR_PREV_FLAG,
            HW.DATE_KEY,
            H.GEO_KEY,
            H.COUNTY,
            LKP.MSA_NAME,
            H.STATE_CODE,
            H.STATE_NAME,
            HW.COUNTRY_NAME,
            H.COUNTY_POPULATION,
            H.COUNTY_POP_RNK,
            H.CASES_TODATE_PER100K,
            H.CASES_TODATE_WK,
            H.NEW_CASES_WK,
            H.NEW_CASES_7MAVG,
            H.NEW_CASES_7MAVG_100K,
            H.DEATHS_TODATE_WK,
            H.NEW_DEATHS_WK,
            H.NEW_DEATHS_7MAVG,
            H.NEW_DEATHS_7MAVG_100K,
            H.RECOVERY_FLAG,
            H.SAFE_FLAG,
            H.SURGE_FLAG,
            DM.BUCKET,
            DM.EST_DATE_START,
            ICU.PEAK_ICU_BED_DAY_MEAN,
            DH.TESTED_CNT,
            DH.CONFIRMED_CNT,
            DH.RECOVERED_CNT,
            DH.DEATH_CNT,
            DH.HOSPITALIZED_CNT,
            DH.ON_VENTILATOR_CNT,
            DH.IN_ICU_CNT,
            DH.SEVERE_CASE_CNT,
            DH.SCHOOL_CLOSING,
            DH.WORKPLACE_CLOSING,
            DH.CANCEL_EVENTS,
            DH.GATHERINGS_RESTRICTIONS,
            DH.TRANSPORT_CLOSING,
            DH.STAY_HOME_RESTRICTIONS,
            DH.INTERNAL_MOVEMENT_RESTRICTIONS,
            DH.INTERNATIONAL_MOVEMENT_RESTRICTIONS,
            DH.INFORMATION_CAMPAIGNS,
            DH.TESTING_POLICY,
            DH.CONTACT_TRACING,
            DH.STRINGENCY_INDEX,
            (
        CASE
            WHEN COALESCE(TRIM(SMSA.MSA_WITH_SITE),'') = '' THEN 0 ELSE 1
        END),
            SA.SITE_ID,
            SA.SITE_TYPE,
            SA.ADDRESS,
            INITCAP(LOWER(SA.CITY)),
            SA.MSA_NAME,
            SA.COUNTY_NAME,
            SA.STATE_NAME,
            SA.FTE_HC_AT_LOCATION,
            SA.CONTINGENT_HC_AT_LOCATION,
            SA.AVERAGE_ATTENDANCE,
            SA.SECURITY_TYPE,
            (
        CASE
            WHEN COALESCE(TRIM(EMSA.MSA_WITH_EMP),'') = '' THEN 0 ELSE 1
        END),
            PL.MSA_NAME,
            PL.COUNTY_NAME,
            PL.STATE_NAME;
			
			
REPLACE VIEW ???.F_IND_DASHBOARD_MOBILITY_GEO_WEEKLY_V AS
LOCKING ROW FOR ACCESS
SELECT
  SNAPSHOT_DATE,
  SNAPSHOT_WEEK,
  CURR_PREV_FLAG,
  DENSE_RANK() OVER (PARTITION BY GEO_KEY, CURR_PREV_FLAG ORDER BY DATE_KEY ASC) CAL_DAY_OF_WEEK,
  GEO_KEY,
  GEO_GRANULARITY,
  COUNTY,
  STATE_CODE,
  STATE_NAME,
  COUNTRY_NAME,
  POPULATION,
  DATE_KEY,
  METRIC_NAME,
  METRIC_INDEX
 FROM
  (
    SELECT 
          DT.SNAPSHOT_DATE,
          DT.SNAPSHOT_WEEK,
          CASE WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
               THEN DT.CURR_PREV_FLAG
          END AS CURR_PREV_FLAG,
          F.GEO_KEY,
          UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
          G.COUNTY, 
          G.STATE_CODE,
          G.STATE_NAME,
          G.COUNTRY_NAME,
          G.POPULATION,
          F.DATE_KEY,
          METRIC_NAME,
          METRIC_INDEX
    FROM 
      ???.FACT_INDICATOR_DASHBOARD_V F 
      JOIN ???.DIM_GEO_LOCATION_V G ON
      F.GEO_KEY = G.UID
      JOIN (SELECT 
       		MAX(WEEK_END_DATE) OVER () AS SNAPSHOT_DATE,
       		MAX(CAL_WEEK_YEAR) OVER () AS SNAPSHOT_WEEK,
       		MIN(WEEK_START_DATE) OVER () AS FIL_START_DATE_KEY,
       		MAX(WEEK_END_DATE) OVER () FIL_END_DATE_KEY,
       		CASE WHEN RNK =1 THEN 'CURR'
            	 WHEN RNK =2 THEN 'PREV'
            	 WHEN RNK =3 THEN 'PREV-1'
            	 WHEN RNK =4 THEN 'PREV-2'
				 WHEN RNK =5 THEN 'PREV-3'
            	 ELSE 'PREV-4'
       		END CURR_PREV_FLAG,
       		RANK() OVER (ORDER BY WEEK_END_DATE DESC) RNK,
       		DT.*
    	   FROM 
            ???.DIM_CALENDAR_V DT
			LEFT JOIN (
                       SELECT MAX(DATE_KEY) MAX_DT
                       FROM ???.FACT_INDICATOR_DASHBOARD_V F  
                       JOIN ???.DIM_GEO_LOCATION_V G ON
                            F.GEO_KEY = G.UID
                       WHERE F.DATA_SOURCE_NAME = 'Google Mobility Report'
                      ) MAXDT ON 1=1
           WHERE CAL_DATE_KEY IN (MAX_DT,MAX_DT-7,MAX_DT-14,MAX_DT-21,MAX_DT-28, MAX_DT-35)
          ) DT ON
       F.DATE_KEY BETWEEN DT.FIL_START_DATE_KEY AND DT.FIL_END_DATE_KEY
    WHERE 
      F.DATA_SOURCE_NAME = 'Google Mobility Report' AND
      CASE WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
           THEN DT.CURR_PREV_FLAG
      END IN ('CURR','PREV','PREV-1','PREV-2','PREV-3')
   ) T;
   
   

REPLACE VIEW ???.XREF_SOURCE_DATA_UPDATES_V  AS
LOCKING ROW FOR ACCESS

SELECT COALESCE(t1.Category,'NON') AS Category,COALESCE(StagingTable,'NON') AS StagingTable,COALESCE(t1.DataSource,'NO STAGING SOURCE DEFINED') AS DataSource,COALESCE(t2.Metric_Name,'NOT USED IN THE REPORTS') AS MetricName,COALESCE(CoreTable,'NOT USED IN THE REPORTS') as CoreTable, COALESCE(t2.MaxAvailableDate,t1.MaxAvailableDate) as MaxAvailableDate
FROM (
	SELECT 'BEA - Personal Consumption 2-3-5' as Category,'STG_BEA_PersonalConsumption_2_3_5' as StagingTable,'Manual                                                                               ' as DataSource, MAX(CAST("PERIOD_MMM-YYYY" AS DATE FORMAT 'MMM-YYYY')) as MaxAvailableDate from ???.STG_BEA_PersonalConsumption_2_3_5
	UNION
	SELECT 'BEA - Personal Consumption 2-4-5','STG_BEA_PersonalConsumption_2_4_5' as StagingTable,'Manual', MAX(CAST("PERIOD_MMM-YYYY" AS DATE FORMAT 'MMM-YYYY')) from ???.STG_BEA_PersonalConsumption_2_4_5
	UNION
	SELECT 'COVID19 National Estimates','STG_COVID19_NATIONAL_ESTIMATES' as StagingTable,'Manual', MAX(CollectionDate) from ???.STG_COVID19_NATIONAL_ESTIMATES
	UNION
	SELECT 'COVID19 Statistics','STG_covid19_stats' as StagingTable,'https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv', MAX(CAST(Date_Key AS DATE FORMAT 'YYYY-MM-DD')) FROM ???.STG_covid19_stats
	UNION
	SELECT 'COVID19 Projections','STG_Hospitalization_all_locs' as StagingTable,'https://ihmecovid19storage.blob.core.windows.net/latest/ihme-covid19.zip', MAX(CAST("Date" AS DATE FORMAT 'YYYY-MM-DD')) FROM ???.STG_Hospitalization_all_locs
	UNION
	SELECT 'Google Trends','STG_Google_Search_IOT' as StagingTable,'Python Pytrends API', MAX(CAST("Date" AS DATE FORMAT 'YYYY-MM-DD')) FROM ???.STG_Google_Search_IOT
	UNION
	SELECT 'Google Mobility','STG_Google_Mobility' as StagingTable,'https://www.gstatic.com/covid19/mobility/Global_Mobility_Report.csv', MAX(CAST(date_key AS DATE FORMAT 'YYYY-MM-DD')) FROM ???.STG_Google_Mobility
	UNION
	SELECT 'COVID19 Datahhub','STG_COVID19_Datahub_LVL3' as StagingTable,'Python Covid19 Datahub', MAX(CAST(date_key AS DATE FORMAT 'YYYY-MM-DD')) FROM ???.STG_COVID19_Datahub_LVL3
	UNION
	SELECT 'Labor Statistics','STG_Labor_Stats_LNS13000000' as StagingTable,'https://api.bls.gov/publicAPI/v2/timeseries/data', MAX(CAST(year_key||'-'||oreplace(period_key,'M',null) AS DATE FORMAT 'YYYY-MM')) FROM ???.STG_Labor_Stats_LNS13000000
	UNION
	SELECT 'Fuel Production','STG_Fuel_Production' as StagingTable,'https://www.eia.gov/dnav/pet/xls/PET_CONS_WPSUP_K_4.xls', MAX(date_key) FROM ???.STG_Fuel_Production
	UNION
	SELECT 'TSA Travel','STG_TSA_TRAVEL' as StagingTable,'https://www.tsa.gov/coronavirus/passenger-throughput', MAX(cast(TO_DATE((lpad(STRTOK(travel_date,'/',1),2,'0')||'/'||lpad(STRTOK(travel_date,'/',1),2,'0')|| '/'||STRTOK(travel_date,'/',3)),'MM/DD/YYYY') as date)) FROM ???.STG_TSA_TRAVEL WHERE Travel_Date is not null
	UNION
	SELECT 'Census Data','STG_US_CENSUS_SURVEY' as StagingTable,'https://www.census.gov/econ/currentdata/export/csv', MAX(CAST("PERIOD" AS DATE FORMAT 'MMM-YYYY')) FROM ???.STG_US_CENSUS_SURVEY
	UNION
	SELECT 'Consumer Sentiment Index','STG_Consumer_Sentiment_Index' as StagingTable,'http://www.sca.isr.umich.edu/files/tbcics.csv', MAX(CAST(SUBSTR("Month",1,3)||'-'||"Year" AS DATE FORMAT 'MMM-YYYY')) FROM ???.STG_Consumer_Sentiment_Index
	UNION
	SELECT 'Consumer Price Index','STG_Labor_Stats_CUSR0000SA0' as StagingTable,'https://api.bls.gov/publicAPI/v2/timeseries/data', MAX(CAST(year_key||'-'||oreplace(period_key,'M',null) AS DATE FORMAT 'YYYY-MM')) FROM ???.STG_Labor_Stats_CUSR0000SA0) t1
	--
FULL OUTER JOIN (SELECT CASE WHEN Metric_Name IN ('Household - Clothing & Footwear','Household - Food Services & Accommodation','Personal Consumption Expenditure (Product Details)') THEN 'BEA - Personal Consumption 2-4-5'
						WHEN Metric_Name IN ('US Product Supplied 4WKAVG') THEN 'Fuel Production'
						WHEN Metric_Name IN ('Unemployment Level','Unemployment Rate') THEN 'Labor Statistics'
						WHEN Metric_Name IN ('CPI') THEN 'Consumer Price Index'
						WHEN Metric_Name IN ('%Mobility_Change_Baseline for Grocery & pharmacy',
											'%Mobility_Change_Baseline for Parks',
											'%Mobility_Change_Baseline for Residential',
											'%Mobility_Change_Baseline for Retail & recreation',
											'%Mobility_Change_Baseline for Transit Stations',
											'%Mobility_Change_Baseline for Workplace') THEN 'Google Mobility'
						WHEN Metric_Name IN ('Consumer Sentiment Index') THEN 'Consumer Sentiment Index'
						WHEN Metric_Name IN ('Traffic Volume') THEN 'TSA Travel'
						WHEN Metric_Name IN ('New Daily Cases','New Daily Deaths','Deaths to-date','Cases to-date') THEN 'COVID19 Statistics'
						WHEN Metric_Name IN ('Total units') THEN 'Census Data'
					END AS Category,
					Metric_Name,'FACT_INDICATOR_DASHBOARD_T2_P' AS CoreTable, MAX(Date_Key) as MaxAvailableDate
			FROM ???.FACT_INDICATOR_DASHBOARD_T2_P
			GROUP BY 1,2
			UNION
			SELECT 'Google Trends',TREND_Name,'F_IND_DASH_GOOGLE_TRENDS', MAX(Date_Key) as MaxAvailableDate
			FROM ???.F_IND_DASH_GOOGLE_TRENDS
			GROUP BY 1,2
			UNION
			SELECT 'COVID19 Datahhub','COVID19 Metrics','FACT_COVID19_DATAHUB', MAX(Date_Key) as MaxAvailableDate
			FROM ???.FACT_COVID19_DATAHUB
			UNION
			SELECT 'COVID19 Projections','COVID19 Projection Metrics','FACT_Covid_Model_Data', MAX(Date_Key) as MaxAvailableDate
			FROM ???.FACT_Covid_Model_Data
			) t2
			--
ON t2.Category = t1.Category;


REPLACE PROCEDURE ???.ETL_BEA_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_BEA_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 2, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert FACT_INDICATOR_DASHBOARD_T2_p Table									 
Procedure syntax  : CALL ETL_BEA_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/02/2020      1.0         Teradata DW              	Initial
07/14/2020		2.0			Teradata DW					Multiplied metric by million to get true count
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_INDICATOR_DASHBOARD_T2_P';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_BEA_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;


/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

--Bureau of Economic Analysis - NIPA Monthly Report T2.4.5U
MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_P as target
USING  
  ( select          x.PROCESS_TYPE,     
    CASE
             WHEN x.PROCESS_TYPE = 'I'
         THEN y.MAX_ID + ROW_NUMBER() OVER(
         ORDER BY x.METRIC_NAME,
           x.DATE_KEY ,
           x.GEO_GRANULARITY ,
           x.DATE_KEY ,
           x.DOMAIN_NAME ,
           x.SUBDOMAIN_1_NAME,
           x.SUBDOMAIN_2_NAME,
           x.SUBDOMAIN_3_NAME 
             )

         ELSE x.INDICATOR_KEY
         END AS INDICATOR_KEY,  	
   	x.Date_key,
    x.DATE_GRANULARITY,
    x.GEO_KEY, 
    x.GEO_GRANULARITY,
    x.DOMAIN_NAME,
    x.SUBDOMAIN_1_NAME,
    x.SUBDOMAIN_2_NAME,
    x.SUBDOMAIN_3_NAME,
    x.METRIC_NAME,
    x.METRIC_VALUE,
    x.METRIC_INDEX,
    x.DATA_SOURCE_NAME,
    x.DATA_SOURCE_DESC,
    x.REC_INS_TS,
    x.REC_UPD_TS
   
from  
  
  (
  
 select b.indicator_key, 
    a.DATE_KEY,
    a.DATE_GRANULARITY,
    a.GEO_KEY,
    a.GEO_GRANULARITY,
    a.DOMAIN_NAME,
    a.SUBDOMAIN_1_NAME,
    a.SUBDOMAIN_2_NAME,
    a.SUBDOMAIN_3_NAME,
    a.METRIC_NAME,
    a.METRIC_VALUE,
    a.METRIC_INDEX,
    a.DATA_SOURCE_NAME,
    a.DATA_SOURCE_DESC, 
    coalesce(b.REC_INS_TS,CURRENT_TIMESTAMP(0)) REC_INS_TS ,
    CURRENT_TIMESTAMP(0) REC_UPD_TS,
    CASE
          WHEN b.INDICATOR_KEY IS NULL
                 THEN 'I'
          WHEN b.INDICATOR_KEY is not null  
          and (a.METRIC_VALUE <> b.METRIC_VALUE or
                a. METRIC_INDEX <> b.METRIC_INDEX) -- put weird logic here
                 THEN 'U'
          ELSE NULL
                     END AS PROCESS_TYPE
    from (
SELECT 
 cast(    
 STRTOK("period_mmm-yyyy",'-',2)||'-'||
 case  STRTOK("period_mmm-yyyy",'-',1)  
   when 'jan' then '01'
   when 'feb' then '02'
   when 'mar' then '03'
   when 'apr' then '04'
   when 'may' then '05'
   when 'jun' then '06'
   when 'jul' then '07'
   when 'aug' then '08'
   when 'sep' then '09'
   when 'oct' then '10'
   when 'nov' then '11'
   when 'dec' then '12'
 end  ||'-01'  as date )  DATE_KEY,
    'Monthly' DATE_GRANULARITY,
    840 GEO_KEY,
    'Country' GEO_GRANULARITY,
   trim( tmp.DOMAIN_NAME )  DOMAIN_NAME,
   trim( tmp.SUBDOMAIN_1_NAME) SUBDOMAIN_1_NAME,
   trim( tmp.SUBDOMAIN_2_NAME) SUBDOMAIN_2_NAME,
    trim( tmp.SUBDOMAIN_3_NAME)  SUBDOMAIN_3_NAME,
       trim( tmp.SUBDOMAIN_4_NAME)  SUBDOMAIN_4_NAME,
    oreplace(tmp.METRIC_NAME,' M$') METRIC_NAME,
     cast(tmp.METRIC_VALUE as decimal(32,6))  *  cast(1000000 as decimal(32,0))  as   METRIC_VALUE , -- convert to real number
     tmp.METRIC_index,
    tmp.DATA_SOURCE_NAME,
    tmp.DATA_SOURCE_DESC 
 
   FROM   ???.STG_BEA_PersonalConsumption_2_4_5  tmp
   where subdomain_4_name = 'Total') a
           -- FROM ???.STG_BureauEconomicAnalysis             

        LEFT OUTER JOIN ???.FACT_INDICATOR_DASHBOARD_v b
           ON  a.METRIC_NAME = b.METRIC_NAME
           and a.DATE_KEY = b.DATE_KEY
           and a.GEO_GRANULARITY = b.GEO_GRANULARITY
           and a.GEO_key = b.GEO_key
           and a.DOMAIN_NAME = b.DOMAIN_NAME
           and a.SUBDOMAIN_1_NAME = b.SUBDOMAIN_1_NAME
           and a.SUBDOMAIN_2_NAME = b.SUBDOMAIN_2_NAME
           and a.SUBDOMAIN_3_NAME = b.SUBDOMAIN_3_NAME 
       
                ) AS x

        
          CROSS JOIN
                (SELECT
                                ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
                 FROM
                                ???.FACT_INDICATOR_DASHBOARD_v
                ) AS y  
           WHERE x.PROCESS_TYPE IS NOT NULL 
            
)  as source
  

-- join on primary key is obligatory

ON  source.INDICATOR_KEY = target.INDICATOR_KEY
 and source.date_key = target.date_key
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	
     INDICATOR_KEY,  	
   	Date_key,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
     DATA_SOURCE_DESC,
     REC_INS_TS,
     REC_UPD_TS  ) 
values ( 
		
     source.INDICATOR_KEY,  	
   	source.Date_key,
    source.DATE_GRANULARITY,
    source.GEO_KEY, 
    source.GEO_GRANULARITY,
    source.DOMAIN_NAME,
    source.SUBDOMAIN_1_NAME,
    source.SUBDOMAIN_2_NAME,
    source.SUBDOMAIN_3_NAME,
    source.METRIC_NAME,
    source.METRIC_VALUE,
    source.METRIC_INDEX,
    source.DATA_SOURCE_NAME,
    source.DATA_SOURCE_DESC,
    source.REC_INS_TS,
    source.REC_UPD_TS   )
     when matched then
 update 
 set  METRIC_VALUE = source.METRIC_VALUE
 , METRIC_INDEX = source.METRIC_INDEX
 , REC_UPD_TS = source.REC_UPD_TS ; 
	
	
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;


REPLACE PROCEDURE ???.ETL_CENSUS_DATA_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_CENSUS_DATA_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 19, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert FACT_INDICATOR_DASHBOARD_T2_P Table									 
Procedure syntax  : CALL ETL_CENSUS_DATA_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/19/2020      1.0         Teradata DW              	Initial
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_INDICATOR_DASHBOARD_T2_P';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_CENSUS_DATA_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_p as target
USING  
  ( select          x.PROCESS_TYPE,     
    CASE
             WHEN x.PROCESS_TYPE = 'I'
         THEN y.MAX_ID + ROW_NUMBER() OVER(
         ORDER BY x.METRIC_NAME,
           x.DATE_KEY ,
           x.GEO_GRANULARITY ,
           x.DATE_KEY ,
           x.DOMAIN_NAME ,
           x.SUBDOMAIN_1_NAME,
           x.SUBDOMAIN_2_NAME,
           x.SUBDOMAIN_3_NAME 
             )

         ELSE x.INDICATOR_KEY
         END AS INDICATOR_KEY,  	
   	x.Date_key,
    x.DATE_GRANULARITY,
    x.GEO_KEY, 
    x.GEO_GRANULARITY,
    x.DOMAIN_NAME,
    x.SUBDOMAIN_1_NAME,
    x.SUBDOMAIN_2_NAME,
    x.SUBDOMAIN_3_NAME,
    x.METRIC_NAME,
    x.METRIC_VALUE,
    x.METRIC_INDEX,
    x.DATA_SOURCE_NAME,
    x.DATA_SOURCE_DESC,
    x.REC_INS_TS,
    x.REC_UPD_TS
   --select *  
from ( 
SELECT 
	PROCESS_TYPE,
-- a. contains the source data
-- b. contains the target data that matches the nkey of the source data
	a.INDICATOR_KEY,  	
   	a.Date_key,
    a.DATE_GRANULARITY,
    a.GEO_KEY, 
    a.GEO_GRANULARITY,
    a.DOMAIN_NAME,
    a.SUBDOMAIN_1_NAME,
    a.SUBDOMAIN_2_NAME,
    a.SUBDOMAIN_3_NAME,
    a.METRIC_NAME,
    a.METRIC_VALUE,
    a.METRIC_INDEX,
    a.DATA_SOURCE_NAME,
    a.DATA_SOURCE_DESC,
    a.REC_INS_TS,
    a.REC_upd_TS
     
-- if b. is null that means there was no match so set the process type to insert
-- if b. is not null then compare source to target data of updatable columns to determin if there should be an update       
     
      
      FROM
  
  (
  select b.INDICATOR_KEY,
     	aa.Date_key,
    aa.DATE_GRANULARITY,
    aa.GEO_KEY, 
    aa.GEO_GRANULARITY,
    aa.DOMAIN_NAME,
    aa.SUBDOMAIN_1_NAME,
    aa.SUBDOMAIN_2_NAME,
    aa.SUBDOMAIN_3_NAME,
    aa.METRIC_NAME,
    aa.METRIC_VALUE,
    aa.METRIC_INDEX,
    aa.DATA_SOURCE_NAME,
    aa.DATA_SOURCE_DESC,
    aa.REC_INS_TS,
    aa.REC_UPD_TS,
     CASE
          WHEN b.INDICATOR_KEY IS NULL
                 THEN 'I'
          WHEN b.INDICATOR_KEY is not null  
          and (aa.METRIC_VALUE <> b.METRIC_VALUE or
               aa. METRIC_INDEX <> b.METRIC_INDEX) -- put weird logic here
                 THEN 'U'
          ELSE NULL
                     END AS PROCESS_TYPE
        from  ( 
      
  SELECT   'Monthly' date_granularity,
           840 GEO_KEY, 
    'Country' GEO_GRANULARITY,
 cast(    
 STRTOK(period,'-',2)||'-'||
 case  STRTOK(period,'-',1)  
   when 'jan' then '01'
   when 'feb' then '02'
   when 'mar' then '03'
   when 'apr' then '04'
   when 'may' then '05'
   when 'jun' then '06'
   when 'jul' then '07'
   when 'aug' then '08'
   when 'sep' then '09'
   when 'oct' then '10'
   when 'nov' then '11'
   when 'dec' then '12'
 end  ||'-01'  as date )  DATE_KEY ,       
    case when "value" = 'NA' then null else cast("value" as integer) * 1000 end  METRIC_VALUE ,
    0   METRIC_index,
    'US Census' DATA_SOURCE_NAME, 
    DATA_SOURCE_DESC,
    
    'New Residential Construction' DOMAIN_NAME,
        'Annual Rate for Housing Units Authorized' SUBDOMAIN_1_NAME,
        'Total' SUBDOMAIN_2_NAME,
        'Total' SUBDOMAIN_3_NAME,
        
    'Total units' METRIC_NAME,
        CURRENT_TIMESTAMP(0) REC_INS_TS,
        CURRENT_TIMESTAMP(0) REC_UPD_TS --select * 
    
    FROM  ???.STG_US_CENSUS_SURVEY 
        
 where  METRIC_VALUE is not null

        
        ) aa     
        LEFT OUTER JOIN ???.FACT_INDICATOR_DASHBOARD_v b
           ON  aa.METRIC_NAME = b.METRIC_NAME
           and aa.DATE_KEY = b.DATE_KEY
           and aa.GEO_GRANULARITY = b.GEO_GRANULARITY
           and aa.DATE_KEY = b.DATE_KEY
           and aa.DOMAIN_NAME = b.DOMAIN_NAME
           and aa.SUBDOMAIN_1_NAME = b.SUBDOMAIN_1_NAME
           and aa.SUBDOMAIN_2_NAME = b.SUBDOMAIN_2_NAME
           and aa.SUBDOMAIN_3_NAME = b.SUBDOMAIN_3_NAME
           )  a
                ) AS x

        
          CROSS JOIN
                (SELECT
                                ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
                            
                 FROM
                                ???.FACT_INDICATOR_DASHBOARD_v  
                ) AS y  
           WHERE x.PROCESS_TYPE IS NOT NULL 
            
)  as source
  

-- join on primary key is obligatory

ON  source.INDICATOR_KEY = target.INDICATOR_KEY
and source.date_key = target.date_key
 
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	
     INDICATOR_KEY,  	
   	Date_key,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
     DATA_SOURCE_DESC,
     REC_INS_TS,
     REC_UPD_TS  ) 
values ( 
		
     source.INDICATOR_KEY,  	
   	source.Date_key,
    source.DATE_GRANULARITY,
    source.GEO_KEY, 
    source.GEO_GRANULARITY,
    source.DOMAIN_NAME,
    source.SUBDOMAIN_1_NAME,
    source.SUBDOMAIN_2_NAME,
    source.SUBDOMAIN_3_NAME,
    source.METRIC_NAME,
    source.METRIC_VALUE,
    source.METRIC_INDEX,
    source.DATA_SOURCE_NAME,
    source.DATA_SOURCE_DESC,
    source.REC_INS_TS,
    source.REC_UPD_TS   )
     when matched then
 update 
 set  METRIC_VALUE = source.METRIC_VALUE
 , METRIC_INDEX = source.METRIC_INDEX
 , REC_UPD_TS = source.REC_UPD_TS;
 
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;


REPLACE PROCEDURE ???.ETL_CONSUMER_SENTIMENT_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_CONSUMER_SENTIMENT_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 15, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert FACT_INDICATOR_DASHBOARD_T2_p Table									 
Procedure syntax  : CALL ETL_CONSUMER_SENTIMENT_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/15/2020      1.0         Teradata DW              	Initial                                         					
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_INDICATOR_DASHBOARD_T2_P';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_CONSUMER_SENTIMENT_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_P as target
USING  
  ( select x.PROCESS_TYPE,     
    CASE WHEN x.PROCESS_TYPE = 'I' THEN y.MAX_ID + ROW_NUMBER() OVER(ORDER BY	x.METRIC_NAME,
																	       		x.DATE_KEY ,
																		     	x.GEO_GRANULARITY ,
																		        x.DATE_KEY ,
																		        x.DOMAIN_NAME ,
																		        x.SUBDOMAIN_1_NAME,
																		        x.SUBDOMAIN_2_NAME,
																		        x.SUBDOMAIN_3_NAME)
																				ELSE x.INDICATOR_KEY
																				END AS INDICATOR_KEY,  	
   	x.Date_key,
    x.DATE_GRANULARITY,
    x.GEO_KEY, 
    x.GEO_GRANULARITY,
    x.DOMAIN_NAME,
    x.SUBDOMAIN_1_NAME,
    x.SUBDOMAIN_2_NAME,
    x.SUBDOMAIN_3_NAME,
    x.METRIC_NAME,
    x.METRIC_VALUE,
    x.METRIC_INDEX,
    x.DATA_SOURCE_NAME,
    x.DATA_SOURCE_DESC,
    x.REC_INS_TS,
    x.REC_UPD_TS
	from ( SELECT PROCESS_TYPE,
				-- a. contains the source data
				-- b. contains the target data that matches the nkey of the source data
				a.INDICATOR_KEY,  	
			   	a.Date_key,
			    a.DATE_GRANULARITY,
			    a.GEO_KEY, 
			    a.GEO_GRANULARITY,
			    a.DOMAIN_NAME,
			    a.SUBDOMAIN_1_NAME,
			    a.SUBDOMAIN_2_NAME,
			    a.SUBDOMAIN_3_NAME,
			    a.METRIC_NAME,
			    a.METRIC_VALUE,
			    a.METRIC_INDEX,
			    a.DATA_SOURCE_NAME,
			    a.DATA_SOURCE_DESC,
			    a.REC_INS_TS,
			    a.REC_upd_TS
				-- if b. is null that means there was no match so set the process type to insert
				-- if b. is not null then compare source to target data of updatable columns to determin if there should be an update       
			FROM ( select 	b.INDICATOR_KEY,
						    aa.Date_key,
						    aa.DATE_GRANULARITY,
						    aa.GEO_KEY, 
						    aa.GEO_GRANULARITY,
						    aa.DOMAIN_NAME,
						    aa.SUBDOMAIN_1_NAME,
						    aa.SUBDOMAIN_2_NAME,
						    aa.SUBDOMAIN_3_NAME,
						    aa.METRIC_NAME,
						    aa.METRIC_VALUE,
						    aa.METRIC_INDEX,
						    aa.DATA_SOURCE_NAME,
						    aa.DATA_SOURCE_DESC,
						    aa.REC_INS_TS,
						    aa.REC_UPD_TS,
						    CASE WHEN b.INDICATOR_KEY IS NULL THEN 'I'
						        WHEN b.INDICATOR_KEY is not null and (aa.METRIC_VALUE <> b.METRIC_VALUE or aa. METRIC_INDEX <> b.METRIC_INDEX) -- put weird logic here
								THEN 'U'
						        ELSE NULL END AS PROCESS_TYPE
					from  ( SELECT  CASE "month"
						            WHEN 'January' THEN '01'
						            WHEN 'February' THEN '02'
						            WHEN 'March' THEN '03'
						            WHEN 'April' THEN '04'
						            WHEN 'May' THEN '05'
						            WHEN 'June' THEN '06'
						            WHEN 'July' THEN '07'
						            WHEN 'August' THEN '08'
						            WHEN 'September' THEN '09'
						            WHEN 'October' THEN '10'
						            WHEN 'November' THEN '11'
						            WHEN 'December' THEN '12'END mth,
        							cast("year" || '/' || MTH || '/01' as date format 'yyyy/mm/dd') DATE_KEY,
									'Monthly' DATE_GRANULARITY , 
									'840' GEO_KEY  ,
									'Country' GEO_GRANULARITY,  
									'Consumer Sentiment Index'  DOMAIN_NAME ,  
									' ' SUBDOMAIN_1_NAME	,
									' ' SUBDOMAIN_2_NAME	,
									' ' SUBDOMAIN_3_NAME	,
									'Consumer Sentiment Index' METRIC_NAME,
									0  METRIC_VALUE	 ,
									CAST( Consumer_Sentiment_Index AS DECIMAL(15,2))   METRIC_index ,
									'Consumer Sentiment Index' DATA_SOURCE_NAME ,
									'Consumer Sentiment Index' DATA_SOURCE_DESC ,
									 current_timestamp(0) REC_INS_TS, 	 
									current_timestamp(0) REC_UPD_TS
        					FROM ???.STG_Consumer_Sentiment_Index ) aa     
			        LEFT OUTER JOIN ???.FACT_INDICATOR_DASHBOARD_v b
			           ON  aa.METRIC_NAME = b.METRIC_NAME
			           and aa.DATE_KEY = b.DATE_KEY
			           and aa.GEO_GRANULARITY = b.GEO_GRANULARITY
			           and aa.geo_KEY = b.geo_KEY
			           and aa.DOMAIN_NAME = b.DOMAIN_NAME
			           and aa.SUBDOMAIN_1_NAME = b.SUBDOMAIN_1_NAME
			           and aa.SUBDOMAIN_2_NAME = b.SUBDOMAIN_2_NAME
			           and aa.SUBDOMAIN_3_NAME = b.SUBDOMAIN_3_NAME
			           )  a
					   ) AS x
					   --
          CROSS JOIN
                (SELECT ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
                 FROM ???.FACT_INDICATOR_DASHBOARD_v   
                ) AS y  
           WHERE x.PROCESS_TYPE IS NOT NULL 
            
)  as source
  

-- join on primary key is obligatory

ON  source.INDICATOR_KEY = target.INDICATOR_KEY
and source.date_key = target.date_key
 
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	
     INDICATOR_KEY,  	
   	Date_key,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
     DATA_SOURCE_DESC,
     REC_INS_TS,
     REC_UPD_TS  ) 
values ( 
		
     source.INDICATOR_KEY,  	
   	source.Date_key,
    source.DATE_GRANULARITY,
    source.GEO_KEY, 
    source.GEO_GRANULARITY,
    source.DOMAIN_NAME,
    source.SUBDOMAIN_1_NAME,
    source.SUBDOMAIN_2_NAME,
    source.SUBDOMAIN_3_NAME,
    source.METRIC_NAME,
    source.METRIC_VALUE,
    source.METRIC_INDEX,
    source.DATA_SOURCE_NAME,
    source.DATA_SOURCE_DESC,
    source.REC_INS_TS,
    source.REC_UPD_TS   );
	
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;


REPLACE PROCEDURE ???.ETL_COVID_CASES_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_COVID_CASES_CORE                                                 		
Developed By      : Teradata Team                                                                            			  
Created           : June 26, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert FACT_INDICATOR_DASHBOARD_T2_p Table									 
Procedure syntax  : CALL ETL_COVID_CASES_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
06/26/2020      1.0         Teradata DW              	Initial
07/21/2020      2.0         Teradata DW              	Added Moving Average Physical Tables & Stats Collection
07/22/2020		3.0			Teradata DW					Replaced the entire code to be incremental
07/26/2020		4.0			Teradata DW					Added the historical one time load step which is only run for new installations
07/29/2020		5.0			Teradata DW					Modified the the merge
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_INDICATOR_DASHBOARD_T2_p';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_BaseData INTEGER;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_COVID_CASES_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;


/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

-- New York Times covid case cases
-- Historical Load
-- 07.29.20 Changes
SELECT COUNT(*) INTO v_BaseData
FROM ???.FACT_INDICATOR_DASHBOARD_T2_P
WHERE DOMAIN_NAME = 'Covid19 NYT';

IF v_BaseData = 0 THEN -- One time Historical Load
--
MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_P AS TGT
USING  
  ( 
    SELECT 
		  COALESCE(F.INDICATOR_KEY, MAXKEY.MAX_ID + ROW_NUMBER() OVER (ORDER BY T2.DATE_KEY, T2.GEO_KEY, T2.DOMAIN_NAME, T2.SUBDOMAIN_1_NAME, T2.SUBDOMAIN_2_NAME, T2.SUBDOMAIN_3_NAME, T2.METRIC_NAME)) AS INDICATOR_KEY,
		  T2.DATE_KEY,
		  T2.DATE_GRANULARITY,
		  T2.GEO_KEY,
		  T2.GEO_GRANULARITY,
		  T2.DOMAIN_NAME,
		  T2.SUBDOMAIN_1_NAME,
		  T2.SUBDOMAIN_2_NAME,
		  T2.SUBDOMAIN_3_NAME,
		  T2.METRIC_NAME,
		  T2.METRIC_VALUE,
		  0 AS METRIC_INDEX,
		  T2.DATA_SOURCE_NAME,
		  T2.DATA_SOURCE_DESC,
		  CURRENT_TIMESTAMP(0) AS REC_INS_TS,
		  CURRENT_TIMESTAMP(0) AS REC_UPD_TS,
		  CASE WHEN F.INDICATOR_KEY IS NULL
		       THEN 'I'
	    	   WHEN F.INDICATOR_KEY IS NOT NULL AND F.METRIC_VALUE <> T2.METRIC_VALUE
			   THEN 'U'
		       ELSE 'P'
		  END AS INS_UPD_FLAG
	FROM
                    ( SELECT 
		                  T1.DATE_KEY,
                          'Day'  AS DATE_GRANULARITY,
                          GK.UID AS GEO_KEY,
                          T1.GEO_GRANULARITY,
                          'Covid19 NYT'  DOMAIN_NAME,
                          ' ' SUBDOMAIN_1_NAME,
                          ' ' SUBDOMAIN_2_NAME,
                          ' ' SUBDOMAIN_3_NAME,
                          T1.CASES,
						  T1.DAILY_NEW_CASES,
		                  T1.DEATHS,
						  T1.DAILY_NEW_DEATHS,
                          'New York Times Covid cases/deaths reporting' AS DATA_SOURCE_NAME,
                          'New York Times Covid cases/deaths reporting' AS DATA_SOURCE_DESC  
                      FROM
                            (
                               SELECT 
                                     COALESCE(M.CAL_DATE_KEY,CAST(S.DATE_KEY AS DATE FORMAT 'YYYY-MM-DD')) AS DATE_KEY,
                                     CASE WHEN COALESCE(M.COUNTY,S.COUNTY) = 'Unknown'
                                          THEN 'STATE'
                                          ELSE COALESCE(M.GEO_GRANULARITY,'COUNTY')
                                     END AS GEO_GRANULARITY,
                                     COALESCE(M.COUNTY,S.COUNTY) AS COUNTY,
                                     MIN(COALESCE(M.STATE_CODE,'ZZ')) OVER (PARTITION BY COALESCE(M.STATE_NAME,S.STATE) ORDER BY M.STATE_CODE) AS STATE_CODE,
                                     COALESCE(M.STATE_NAME,S.STATE) AS STATE_NAME,
				                     COALESCE(S.CASES,0) AS CASES,
									 COALESCE(COALESCE(S.CASES - LAG(S.CASES,1) OVER (PARTITION BY COALESCE(M.COUNTY,S.COUNTY),COALESCE(M.STATE_NAME,S.STATE) 
									                                                  ORDER BY COALESCE(M.CAL_DATE_KEY,CAST(S.DATE_KEY AS DATE FORMAT 'YYYY-MM-DD'))),S.CASES -1),0) AS DAILY_NEW_CASES,
                                     COALESCE(S.DEATHS,0) AS DEATHS,
									 COALESCE(COALESCE(S.DEATHS - LAG(S.DEATHS,1) OVER (PARTITION BY COALESCE(M.COUNTY,S.COUNTY),COALESCE(M.STATE_NAME,S.STATE) 
									                                                    ORDER BY COALESCE(M.CAL_DATE_KEY,CAST(S.DATE_KEY AS DATE FORMAT 'YYYY-MM-DD'))),S.DEATHS-1),0) AS DAILY_NEW_DEATHS
                               FROM
                                (
                                  SELECT 
                                     DT.CAL_DATE_KEY,
                                     GC.UID AS GEO_KEY,
                                     GC.GEO_GRANULARITY,
                                     GC.COUNTY, 
                                     GC.COUNTY_LONG,
                                     GC.STATE_CODE,
                                     GC.STATE_NAME 
                                  FROM 
                                     ???.DIM_GEO_LOCATION_V GC
                                     JOIN ???.DIM_CALENDAR_V DT ON
                                     DT.CAL_DATE_KEY BETWEEN (SELECT MIN(DATE_KEY) FROM ???.STG_COVID19_STATS) AND (SELECT MAX(DATE_KEY) FROM ???.STG_COVID19_STATS) AND
                                     GC.GEO_GRANULARITY = 'COUNTY' AND 
                                     GC.COUNTRY_CODE    = 'US'
                                ) M
                                FULL OUTER JOIN
                                (
                                   SELECT 
                                      DATE_KEY,
                                      CASE WHEN COUNTY = 'New York City'
					                       THEN 'New York'
						                   ELSE COUNTY
				                      END AS COUNTY,             -- New York City is a combination of 5 counties - it will be loaded to NY County and corrected later
                                      STATE,
                                      CASES,
                                      DEATHS
                                   FROM 
                                     ???.STG_COVID19_STATS
                                   WHERE 
                                     DATE_KEY BETWEEN (SELECT MIN(DATE_KEY) FROM ???.STG_COVID19_STATS) AND (SELECT MAX(DATE_KEY) FROM ???.STG_COVID19_STATS)
                                 ) S ON 
                                 S.DATE_KEY = M.CAL_DATE_KEY AND
                                 S.COUNTY IN (M.COUNTY, M.COUNTY_LONG) AND
                                 S.STATE    = M.STATE_NAME
                            ) T1     
                            JOIN ???.DIM_GEO_LOCATION_V GK ON
                            T1.GEO_GRANULARITY = GK.GEO_GRANULARITY AND
                            T1.STATE_NAME      = GK.STATE_NAME AND 
                            T1.COUNTY          = COALESCE(GK.COUNTY,'Unknown')	
							--WHERE T1.DATE_KEY >= CURRENT_DATE -29  -- for incremental loads, need to filter first date because the daily new cases/deaths calculation is incorrect
                    )  NYT 
             UNPIVOT ((METRIC_VALUE)  FOR  METRIC_NAME 
                                      IN ((CASES)  AS 'Cases to-date', 
									      (DAILY_NEW_CASES) AS 'New Daily Cases',
                                          (DEATHS) AS 'Deaths to-date',
										  (DAILY_NEW_DEATHS) AS 'New Daily Deaths'
										 )
		             )  T2
		 LEFT OUTER JOIN ???.FACT_INDICATOR_DASHBOARD_V F ON
		         T2.DATE_KEY         = F.DATE_KEY             AND
		         T2.DATE_GRANULARITY = F.DATE_GRANULARITY     AND
		         T2.GEO_KEY          = F.GEO_KEY              AND
		         T2.GEO_GRANULARITY  = F.GEO_GRANULARITY      AND
		         T2.DOMAIN_NAME      = F.DOMAIN_NAME          AND
                 T2.SUBDOMAIN_1_NAME = F.SUBDOMAIN_1_NAME     AND
                 T2.SUBDOMAIN_2_NAME = F.SUBDOMAIN_2_NAME     AND
                 T2.SUBDOMAIN_3_NAME = F.SUBDOMAIN_3_NAME     AND
		         T2.METRIC_NAME      = F.METRIC_NAME
		 LEFT OUTER JOIN (SELECT ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
		                  FROM ???.FACT_INDICATOR_DASHBOARD_V) MAXKEY ON 
		          1=1
 	     WHERE
            INS_UPD_FLAG IN ('I','U')	
  )  STG ON  
STG.INDICATOR_KEY = TGT.INDICATOR_KEY AND
STG.DATE_KEY      = TGT.DATE_KEY
WHEN NOT MATCHED THEN 
INSERT
  (       
    INDICATOR_KEY,     
    DATE_KEY,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
    DATA_SOURCE_DESC,
    REC_INS_TS,
    REC_UPD_TS  
   )  VALUES 
   (    
    STG.INDICATOR_KEY,      
    STG.DATE_KEY,
    STG.DATE_GRANULARITY,
    STG.GEO_KEY, 
    STG.GEO_GRANULARITY,
    STG.DOMAIN_NAME,
    STG.SUBDOMAIN_1_NAME,
    STG.SUBDOMAIN_2_NAME,
    STG.SUBDOMAIN_3_NAME,
    STG.METRIC_NAME,
    STG.METRIC_VALUE,
    STG.METRIC_INDEX,
    STG.DATA_SOURCE_NAME,
    STG.DATA_SOURCE_DESC,
    STG.REC_INS_TS,
    STG.REC_UPD_TS   
  )
WHEN MATCHED THEN
UPDATE SET 
    METRIC_VALUE  = STG.METRIC_VALUE,
    METRIC_INDEX  = STG.METRIC_INDEX,
    REC_UPD_TS    = STG.REC_UPD_TS ;
	
	
	
	
UPDATE ???.FACT_INDICATOR_DASHBOARD_T2_P
FROM (
SELECT
   F.INDICATOR_KEY,
   F.DATE_KEY,
   F.GEO_KEY,
   G.POPULATION,
   G.STATE_CODE,
   F.DOMAIN_NAME,
   F.METRIC_NAME,
   F.METRIC_VALUE,
   SUM(F.METRIC_VALUE) OVER (PARTITION BY F.DATE_KEY, F.DOMAIN_NAME, F.METRIC_NAME,G.STATE_CODE) AS TOT_METRIC_VALUE,
   SUM(G.POPULATION) OVER (PARTITION BY F.DATE_KEY, F.DOMAIN_NAME, F.METRIC_NAME, G.STATE_CODE) AS TOT_POPULATION,
   (SUM(F.METRIC_VALUE) OVER (PARTITION BY F.DATE_KEY, F.DOMAIN_NAME, F.METRIC_NAME,G.STATE_CODE) * 
    CAST(G.POPULATION AS DECIMAL(38,6))/SUM(G.POPULATION) OVER (PARTITION BY F.DATE_KEY, F.DOMAIN_NAME, F.METRIC_NAME,G.STATE_CODE)) AS NEW_METRIC_VALUE
FROM
   ???.FACT_INDICATOR_DASHBOARD_V F
   JOIN ???.DIM_GEO_LOCATION_V G ON
   F.GEO_KEY = G.UID
WHERE
   F.DOMAIN_NAME = 'Covid19 NYT' AND
   F.GEO_KEY IN (84070003,84029037,84029047,84029095,84029165,84036061,84036005,84036047,84036081,84036085) AND
   F.DATE_KEY BETWEEN CURRENT_DATE -30 AND CURRENT_DATE
) AS SRC
SET METRIC_VALUE = SRC.NEW_METRIC_VALUE,
    REC_UPD_TS      = CURRENT_TIMESTAMP(0)
WHERE 
   FACT_INDICATOR_DASHBOARD_T2_P.INDICATOR_KEY = SRC.INDICATOR_KEY;
      
END IF;
	
-----------------------------------------------------------
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
-----------------------------------------------------------
   
-- Incremental Load
-- 07.29.20 Changes
MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_P AS TGT
USING  
  ( 
    SELECT 
		  COALESCE(F.INDICATOR_KEY, MAXKEY.MAX_ID + ROW_NUMBER() OVER (ORDER BY T2.DATE_KEY, T2.GEO_KEY, T2.DOMAIN_NAME, T2.SUBDOMAIN_1_NAME, T2.SUBDOMAIN_2_NAME, T2.SUBDOMAIN_3_NAME, T2.METRIC_NAME)) AS INDICATOR_KEY,
		  T2.DATE_KEY,
		  T2.DATE_GRANULARITY,
		  T2.GEO_KEY,
		  T2.GEO_GRANULARITY,
		  T2.DOMAIN_NAME,
		  T2.SUBDOMAIN_1_NAME,
		  T2.SUBDOMAIN_2_NAME,
		  T2.SUBDOMAIN_3_NAME,
		  T2.METRIC_NAME,
		  T2.METRIC_VALUE,
		  0 AS METRIC_INDEX,
		  T2.DATA_SOURCE_NAME,
		  T2.DATA_SOURCE_DESC,
		  CURRENT_TIMESTAMP(0) AS REC_INS_TS,
		  CURRENT_TIMESTAMP(0) AS REC_UPD_TS,
		  CASE WHEN F.INDICATOR_KEY IS NULL
		       THEN 'I'
	    	   WHEN F.INDICATOR_KEY IS NOT NULL AND F.METRIC_VALUE <> T2.METRIC_VALUE
			   THEN 'U'
		       ELSE 'P'
		  END AS INS_UPD_FLAG
	FROM
                    ( SELECT 
		                  T1.DATE_KEY,
                          'Day'  AS DATE_GRANULARITY,
                          GK.UID AS GEO_KEY,
                          T1.GEO_GRANULARITY,
                          'Covid19 NYT'  DOMAIN_NAME,
                          ' ' SUBDOMAIN_1_NAME,
                          ' ' SUBDOMAIN_2_NAME,
                          ' ' SUBDOMAIN_3_NAME,
                          T1.CASES,
						  T1.DAILY_NEW_CASES,
		                  T1.DEATHS,
						  T1.DAILY_NEW_DEATHS,
                          'New York Times Covid cases/deaths reporting' AS DATA_SOURCE_NAME,
                          'New York Times Covid cases/deaths reporting' AS DATA_SOURCE_DESC  
                      FROM
                            (
                               SELECT 
                                     COALESCE(M.CAL_DATE_KEY,CAST(S.DATE_KEY AS DATE FORMAT 'YYYY-MM-DD')) AS DATE_KEY,
                                     CASE WHEN COALESCE(M.COUNTY,S.COUNTY) = 'Unknown'
                                          THEN 'STATE'
                                          ELSE COALESCE(M.GEO_GRANULARITY,'COUNTY')
                                     END AS GEO_GRANULARITY,
                                     COALESCE(M.COUNTY,S.COUNTY) AS COUNTY,
                                     MIN(COALESCE(M.STATE_CODE,'ZZ')) OVER (PARTITION BY COALESCE(M.STATE_NAME,S.STATE) ORDER BY M.STATE_CODE) AS STATE_CODE,
                                     COALESCE(M.STATE_NAME,S.STATE) AS STATE_NAME,
				                     COALESCE(S.CASES,0) AS CASES,
									 COALESCE(COALESCE(S.CASES - LAG(S.CASES,1) OVER (PARTITION BY COALESCE(M.COUNTY,S.COUNTY),COALESCE(M.STATE_NAME,S.STATE) 
									                                                  ORDER BY COALESCE(M.CAL_DATE_KEY,CAST(S.DATE_KEY AS DATE FORMAT 'YYYY-MM-DD'))),S.CASES -1),0) AS DAILY_NEW_CASES,
                                     COALESCE(S.DEATHS,0) AS DEATHS,
									 COALESCE(COALESCE(S.DEATHS - LAG(S.DEATHS,1) OVER (PARTITION BY COALESCE(M.COUNTY,S.COUNTY),COALESCE(M.STATE_NAME,S.STATE) 
									                                                    ORDER BY COALESCE(M.CAL_DATE_KEY,CAST(S.DATE_KEY AS DATE FORMAT 'YYYY-MM-DD'))),S.DEATHS-1),0) AS DAILY_NEW_DEATHS
                               FROM
                                (
                                  SELECT 
                                     DT.CAL_DATE_KEY,
                                     GC.UID AS GEO_KEY,
                                     GC.GEO_GRANULARITY,
                                     GC.COUNTY, 
                                     GC.COUNTY_LONG,
                                     GC.STATE_CODE,
                                     GC.STATE_NAME 
                                  FROM 
                                     ???.DIM_GEO_LOCATION_V GC
                                     JOIN ???.DIM_CALENDAR_V DT ON
                                     DT.CAL_DATE_KEY BETWEEN CURRENT_DATE -30 AND (SELECT MAX(DATE_KEY) FROM ???.STG_COVID19_STATS) AND
                                     GC.GEO_GRANULARITY = 'COUNTY' AND 
                                     GC.COUNTRY_CODE    = 'US'
                                ) M
                                FULL OUTER JOIN
                                (
                                   SELECT 
                                      DATE_KEY,
                                      CASE WHEN COUNTY = 'New York City'
					                       THEN 'New York'
						                   ELSE COUNTY
				                      END AS COUNTY,             -- New York City is a combination of 5 counties - it will be loaded to NY County and corrected later
                                      STATE,
                                      CASES,
                                      DEATHS
                                   FROM 
                                     ???.STG_COVID19_STATS
                                   WHERE 
                                     DATE_KEY BETWEEN CURRENT_DATE-30 AND (SELECT MAX(DATE_KEY) FROM ???.STG_COVID19_STATS)
                                 ) S ON 
                                 S.DATE_KEY = M.CAL_DATE_KEY AND
                                 S.COUNTY IN (M.COUNTY, M.COUNTY_LONG) AND
                                 S.STATE    = M.STATE_NAME
                            ) T1     
                            JOIN ???.DIM_GEO_LOCATION_V GK ON
                            T1.GEO_GRANULARITY = GK.GEO_GRANULARITY AND
                            T1.STATE_NAME      = GK.STATE_NAME AND 
                            T1.COUNTY          = COALESCE(GK.COUNTY,'Unknown')	
							WHERE T1.DATE_KEY >= CURRENT_DATE -29  -- for incremental loads, need to filter first date because the daily new cases/deaths calculation is incorrect
                    )  NYT 
             UNPIVOT ((METRIC_VALUE)  FOR  METRIC_NAME 
                                      IN ((CASES)  AS 'Cases to-date', 
									      (DAILY_NEW_CASES) AS 'New Daily Cases',
                                          (DEATHS) AS 'Deaths to-date',
										  (DAILY_NEW_DEATHS) AS 'New Daily Deaths'
										 )
		             )  T2
		 LEFT OUTER JOIN ???.FACT_INDICATOR_DASHBOARD_V F ON
		         T2.DATE_KEY         = F.DATE_KEY             AND
		         T2.DATE_GRANULARITY = F.DATE_GRANULARITY     AND
		         T2.GEO_KEY          = F.GEO_KEY              AND
		         T2.GEO_GRANULARITY  = F.GEO_GRANULARITY      AND
		         T2.DOMAIN_NAME      = F.DOMAIN_NAME          AND
                 T2.SUBDOMAIN_1_NAME = F.SUBDOMAIN_1_NAME     AND
                 T2.SUBDOMAIN_2_NAME = F.SUBDOMAIN_2_NAME     AND
                 T2.SUBDOMAIN_3_NAME = F.SUBDOMAIN_3_NAME     AND
		         T2.METRIC_NAME      = F.METRIC_NAME
		 LEFT OUTER JOIN (SELECT ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
		                  FROM ???.FACT_INDICATOR_DASHBOARD_V) MAXKEY ON 
		          1=1
 	     WHERE
            INS_UPD_FLAG IN ('I','U')	
  )  STG ON  
STG.INDICATOR_KEY = TGT.INDICATOR_KEY AND
STG.DATE_KEY      = TGT.DATE_KEY
WHEN NOT MATCHED THEN 
INSERT
  (       
    INDICATOR_KEY,     
    DATE_KEY,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
    DATA_SOURCE_DESC,
    REC_INS_TS,
    REC_UPD_TS  
   )  VALUES 
   (    
    STG.INDICATOR_KEY,      
    STG.DATE_KEY,
    STG.DATE_GRANULARITY,
    STG.GEO_KEY, 
    STG.GEO_GRANULARITY,
    STG.DOMAIN_NAME,
    STG.SUBDOMAIN_1_NAME,
    STG.SUBDOMAIN_2_NAME,
    STG.SUBDOMAIN_3_NAME,
    STG.METRIC_NAME,
    STG.METRIC_VALUE,
    STG.METRIC_INDEX,
    STG.DATA_SOURCE_NAME,
    STG.DATA_SOURCE_DESC,
    STG.REC_INS_TS,
    STG.REC_UPD_TS   
  )
WHEN MATCHED THEN
UPDATE SET 
    METRIC_VALUE  = STG.METRIC_VALUE,
    METRIC_INDEX  = STG.METRIC_INDEX,
    REC_UPD_TS    = STG.REC_UPD_TS ;
	
	
-----------------------------------------------------------
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
-----------------------------------------------------------	

	
UPDATE ???.FACT_INDICATOR_DASHBOARD_T2_P
FROM (
SELECT
   F.INDICATOR_KEY,
   F.DATE_KEY,
   F.GEO_KEY,
   G.POPULATION,
   G.STATE_CODE,
   F.DOMAIN_NAME,
   F.METRIC_NAME,
   F.METRIC_VALUE,
   SUM(F.METRIC_VALUE) OVER (PARTITION BY F.DATE_KEY, F.DOMAIN_NAME, F.METRIC_NAME,G.STATE_CODE) AS TOT_METRIC_VALUE,
   SUM(G.POPULATION) OVER (PARTITION BY F.DATE_KEY, F.DOMAIN_NAME, F.METRIC_NAME, G.STATE_CODE) AS TOT_POPULATION,
   (SUM(F.METRIC_VALUE) OVER (PARTITION BY F.DATE_KEY, F.DOMAIN_NAME, F.METRIC_NAME,G.STATE_CODE) * 
    CAST(G.POPULATION AS DECIMAL(38,6))/SUM(G.POPULATION) OVER (PARTITION BY F.DATE_KEY, F.DOMAIN_NAME, F.METRIC_NAME,G.STATE_CODE)) AS NEW_METRIC_VALUE
FROM
   ???.FACT_INDICATOR_DASHBOARD_V F
   JOIN ???.DIM_GEO_LOCATION_V G ON
   F.GEO_KEY = G.UID
WHERE
   F.DOMAIN_NAME = 'Covid19 NYT' AND
   F.GEO_KEY IN (84070003,84029037,84029047,84029095,84029165,84036061,84036005,84036047,84036081,84036085) AND
   F.DATE_KEY BETWEEN CURRENT_DATE -30 AND CURRENT_DATE
) AS SRC
SET METRIC_VALUE = SRC.NEW_METRIC_VALUE,
    REC_UPD_TS      = CURRENT_TIMESTAMP(0)
WHERE 
   FACT_INDICATOR_DASHBOARD_T2_P.INDICATOR_KEY = SRC.INDICATOR_KEY;
   
   
 
-----------------------------------------------------------
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
-----------------------------------------------------------	


-- 072120 Added Moving Average Physical Tables
DELETE FROM ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT;
INSERT INTO ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT
SELECT
  SNAPSHOT_DATE,
  SNAPSHOT_WEEK,
  CURR_PREV_FLAG,
  RANK() OVER (PARTITION BY GEO_KEY, CURR_PREV_FLAG ORDER BY DATE_KEY ASC) CAL_DAY_OF_WEEK,
  GEO_KEY,
  GEO_GRANULARITY,
  COUNTY,
  STATE_CODE,
  STATE_NAME,
  COUNTRY_NAME,
  POPULATION,
  DATE_KEY,
  CASES_TODATE,
  NEW_CASES,
  DEATHS_TODATE,
  NEW_DEATHS,
  DENSE_RANK() OVER (PARTITION BY COUNTRY_NAME ORDER BY POPULATION DESC) AS COUNTY_POP_RNK,
  CAST(AVG(CASES_TODATE) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5)) AS CASES_TODATE_7MAVG,
  CAST(AVG(NEW_CASES) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5)) AS NEW_CASES_7MAVG,
  CAST(AVG(DEATHS_TODATE) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5)) AS DEATHS_TODATE_7MAVG,
  CAST(AVG(NEW_DEATHS) OVER (PARTITION BY COUNTY, STATE_NAME ORDER BY DATE_KEY DESC ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) AS DECIMAL(38,5)) AS NEW_DEATHS_7MAVG
 FROM
  (
    SELECT 
          DT.SNAPSHOT_DATE,
          DT.SNAPSHOT_WEEK,
          CASE WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
               THEN DT.CURR_PREV_FLAG
          END AS CURR_PREV_FLAG,
          F.GEO_KEY,
          UPPER(F.GEO_GRANULARITY) GEO_GRANULARITY,
          G.COUNTY, 
          G.STATE_CODE,
          G.STATE_NAME,
          G.COUNTRY_NAME,
          G.POPULATION,
          F.DATE_KEY,
          SUM(CASE WHEN UPPER(F.METRIC_NAME) = 'CASES TO-DATE'
                   THEN METRIC_VALUE
          END) AS CASES_TODATE,
          SUM(CASE WHEN UPPER(F.METRIC_NAME) = 'NEW DAILY CASES'
                   THEN METRIC_VALUE
              END) AS NEW_CASES,
          SUM(CASE WHEN UPPER(F.METRIC_NAME) = 'DEATHS TO-DATE'
                   THEN METRIC_VALUE
          END) AS DEATHS_TODATE,
          SUM(CASE WHEN UPPER(F.METRIC_NAME) = 'NEW DAILY DEATHS'
                   THEN METRIC_VALUE
              END) AS NEW_DEATHS
    FROM 
      ???.FACT_INDICATOR_DASHBOARD_V F 
      JOIN ???.DIM_GEO_LOCATION_V G ON
      F.GEO_KEY = G.UID
      JOIN (SELECT 
       		MAX(WEEK_END_DATE) OVER () AS SNAPSHOT_DATE,
       		MAX(CAL_WEEK_YEAR) OVER () AS SNAPSHOT_WEEK,
       		MIN(WEEK_START_DATE) OVER () AS FIL_START_DATE_KEY,
       		MAX(WEEK_END_DATE) OVER () FIL_END_DATE_KEY,
       		CASE WHEN RNK =1 THEN 'CURR'
            	 WHEN RNK =2 THEN 'PREV'
            	 WHEN RNK =3 THEN 'PREV-1'
            	 WHEN RNK =4 THEN 'PREV-2'
				 WHEN RNK =5 THEN 'PREV-3'
            	 ELSE 'PREV-4'
       		END CURR_PREV_FLAG,
       		RANK() OVER (ORDER BY WEEK_END_DATE DESC) RNK,
       		DT.*
    	   FROM 
            ???.DIM_CALENDAR_V DT
			LEFT JOIN (
                       SELECT MAX(DATE_KEY) MAX_DT
                       FROM ???.FACT_INDICATOR_DASHBOARD_V F  
                       JOIN ???.DIM_GEO_LOCATION_V G ON
                            F.GEO_KEY = G.UID
                       WHERE F.DOMAIN_NAME = 'Covid19 NYT' AND  
                             F.GEO_GRANULARITY = 'COUNTY'
                      ) MAXDT ON 1=1
           WHERE CAL_DATE_KEY IN (MAX_DT-7,MAX_DT-14,MAX_DT-21,MAX_DT-28, MAX_DT-35, MAX_DT-42)
          ) DT ON
       F.DATE_KEY BETWEEN DT.FIL_START_DATE_KEY AND DT.FIL_END_DATE_KEY
    WHERE 
      F.DOMAIN_NAME = 'Covid19 NYT' AND 
      F.GEO_GRANULARITY = 'COUNTY'  AND
      CASE WHEN F.DATE_KEY BETWEEN DT.WEEK_START_DATE AND DT.WEEK_END_DATE
           THEN DT.CURR_PREV_FLAG
      END IN ('CURR','PREV','PREV-1','PREV-2','PREV-3')
     GROUP BY 1,2,3,4,5,6,7,8,9,10,11
   ) T;
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;



REPLACE PROCEDURE ???.ETL_COVID_MODEL_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_COVID_MODEL_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : June 26, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert FACT_Covid_Model_Data Table									 
Procedure syntax  : CALL ETL_COVID_MODEL_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
06/26/2020      1.0         Teradata DW              	Initial
07/11/2020		2.0			Teradata DW					Added the insert to FACT_Covid_Model_Data_SUM as target
07/25/2020		3.0			Teradata DW					Modified the STG_Summary_stats_all_locs to not be based on path date
07/29/2020		4.0			Teradata DW					Modified the State join to be US only
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_Covid_Model_Data';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_COVID_MODEL_CORE';
DECLARE v_Date_Key_Val VARCHAR(30);
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

-- 07.25.20 Changes
SELECT CASE WHEN MAX(DATE_KEY) IS NULL THEN DATE 
			ELSE TO_DATE('9999-12-31','YYYY-MM-DD') END into v_Date_Key_Val
FROM ???.FACT_Covid_Model_Data t
WHERE EXISTS (SELECT 1 FROM ???.STG_Hospitalization_all_locs WHERE Path_Update_Dt = t.Path_Update_Val);


IF v_Date_Key_Val <> '9999-12-31'(DATE) THEN
	-- forcasting model
	-- Every version is kept for day over day comparison
	MERGE INTO ???.FACT_Covid_Model_Data as target
	USING  
	  	(select x.PROCESS_TYPE,     
	    		CASE WHEN x.PROCESS_TYPE = 'I'
	        	THEN y.MAX_ID + ROW_NUMBER() OVER(ORDER BY x.location_name,x.Modeled_date)
				ELSE x.MODEL_KEY END AS MODEL_KEY,
	  	x.geo_key,
	  	x.geo_granularity,
	    x.MODEL_VERSION,
	    x.location_name,
	    x.Modeled_date,
	    x.date_key,
	    x.DATE_GRANULARITY,
	    x.allbed_mean,
	    x.allbed_lower,
	    x.allbed_upper,
	    x.ICUbed_mean,
	    x.ICUbed_lower,
	    x.ICUbed_upper,
	    x.InvVen_mean,
	    x.InvVen_lower,
	    x.InvVen_upper,
	    x.deaths_mean,
	    x.deaths_lower,
	    x.deaths_upper,
	    x.admis_mean,
	    x.admis_lower,
	    x.admis_upper,
	    x.newICU_mean,
	    x.newICU_lower,
	    x.newICU_upper,
	    x.totdea_mean,
	    x.totdea_lower,
	    x.totdea_upper,
	    x.bedover_mean,
	    x.bedover_lower,
	    x.bedover_upper,
	    x.icuover_mean,
	    x.icuover_lower,
	    x.icuover_upper,
	    x.deaths_mean_smoothed,
	    x.deaths_lower_smoothed,
	    x.deaths_upper_smoothed,
	    x.totdea_mean_smoothed,
	    x.totdea_lower_smoothed,
	    x.totdea_upper_smoothed,
	    x.mobility_data_type,
	    x.mobility_composite,
	    x.total_tests_data_type,
	    x.total_tests,
	    x.confirmed_infections,
	    x.est_infections_mean,
	    x.est_infections_lower,
	    x.est_infections_upper,
	    x.REC_INS_TS,
	    x.REC_UPD_TS,
		x.Path_Update_Val
	from (
	 	select
	  	b.MODEL_KEY,
	  	a.geo_key,
	  	a.geo_granularity,
	    a.MODEL_VERSION,
	    a.location_name,
	    a.Modeled_date,
	    a.date_key,
	    a.DATE_GRANULARITY,
	    a.allbed_mean,
	    a.allbed_lower,
	    a.allbed_upper,
	    a.ICUbed_mean,
	    a.ICUbed_lower,
	    a.ICUbed_upper,
	    a.InvVen_mean,
	    a.InvVen_lower,
	    a.InvVen_upper,
	    a.deaths_mean,
	    a.deaths_lower,
	    a.deaths_upper,
	    a.admis_mean,
	    a.admis_lower,
	    a.admis_upper,
	    a.newICU_mean,
	    a.newICU_lower,
	    a.newICU_upper,
	    a.totdea_mean,
	    a.totdea_lower,
	    a.totdea_upper,
	    a.bedover_mean,
	    a.bedover_lower,
	    a.bedover_upper,
	    a.icuover_mean,
	    a.icuover_lower,
	    a.icuover_upper,
	    a.deaths_mean_smoothed,
	    a.deaths_lower_smoothed,
	    a.deaths_upper_smoothed,
	    a.totdea_mean_smoothed,
	    a.totdea_lower_smoothed,
	    a.totdea_upper_smoothed,
	    a.mobility_data_type,
	    a.mobility_composite,
	    a.total_tests_data_type,
	    a.total_tests,
	    a.confirmed_infections,
	    a.est_infections_mean,
	    a.est_infections_lower,
	    a.est_infections_upper,
	    coalesce(b.REC_INS_TS,a.REC_INS_TS) REC_INS_TS,
	    a.REC_UPD_TS,
	    CASE WHEN b.MODEL_KEY IS NULL THEN 'I'
	          ELSE NULL END AS PROCESS_TYPE,
		a.Path_Update_Val
	    FROM  ( 
				select 
			 	coalesce(l.uid,-1) geo_key,
			 	coalesce(l.geo_granularity, (select geo_granularity from ???.DIM_GEO_LOCATION_V where uid = -1) ) geo_granularity,
			 	a.V1 MODEL_VERSION,
			    a.location_name,
			    a."date"  Modeled_date, 
			    a.allbed_mean,
			    a.allbed_lower,
			    a.allbed_upper,
			    a.ICUbed_mean,
			    a.ICUbed_lower,
			    a.ICUbed_upper,
			    a.InvVen_mean,
			    a.InvVen_lower,
			    a.InvVen_upper,
			    a.deaths_mean,
			    a.deaths_lower,
			    a.deaths_upper,
			    a.admis_mean,
			    a.admis_lower,
			    a.admis_upper,
			    a.newICU_mean,
			    a.newICU_lower,
			    a.newICU_upper,
			    a.totdea_mean,
			    a.totdea_lower,
			    a.totdea_upper,
			    a.bedover_mean,
			    a.bedover_lower,
			    a.bedover_upper,
			    a.icuover_mean,
			    a.icuover_lower,
			    a.icuover_upper,
			    a.deaths_mean_smoothed,
			    a.deaths_lower_smoothed,
			    a.deaths_upper_smoothed,
			    a.totdea_mean_smoothed,
			    a.totdea_lower_smoothed,
			    a.totdea_upper_smoothed,
			    a.mobility_data_type,
			    a.mobility_composite,
			    a.total_tests_data_type,
			    a.total_tests,
			    a.confirmed_infections,
			    a.est_infections_mean,
			    a.est_infections_lower,
			    a.est_infections_upper,
				current_timestamp(0) REC_INS_TS, 	 
				current_timestamp(0) REC_UPD_TS,
				--cast(Path_Update_Dt as date) date_key,
				v_Date_Key_Val as date_key,
				'Daily' date_granularity,
				a.Path_Update_dt as Path_Update_Val
				from ???.STG_Hospitalization_all_locs a
				left outer join ???.DIM_GEO_LOCATION_V l 
			        	on (a.location_name = l.state_name
						-- 07.29.20 Changes
			        	and l.geo_granularity = 'State' and location_id  between 500 and 599) -- handle Georgia
			        	or (a.location_name = l.country_name
			        	and l.geo_granularity = 'country')
				 
			    --where date_key >= coalesce((select max(date_key) from ???.FACT_Covid_Model_Data),date_key)
	        ) a     
	        LEFT OUTER JOIN ???.FACT_Covid_Model_Data b
	        	on a.geo_key =  b.geo_key 
				and a.Modeled_date = b.Modeled_date
				and a.date_key = b.date_key) AS x

	        CROSS JOIN
	                (SELECT ZEROIFNULL(MAX(Model_KEY)) AS MAX_ID
	                 FROM ???.FACT_Covid_Model_Data 
	                ) AS y  
	        WHERE x.PROCESS_TYPE IS NOT NULL
			
		)  as source
	-- join on primary key is obligatory
	ON  source.Model_KEY = target.Model_KEY
	and source.date_key = target.date_key
	and source.geo_key = target.geo_key
	--
	WHEN NOT MATCHED THEN 
	insert  
	(   	
		MODEL_KEY,
	    DATE_KEY,
	    DATE_GRANULARITY,
	    GEO_KEY,
	    GEO_GRANULARITY,
	    MODEL_VERSION,
	    location_name,
	    Modeled_date,
	    allbed_mean,
	    allbed_lower,
	    allbed_upper,
	    ICUbed_mean,
	    ICUbed_lower,
	    ICUbed_upper,
	    InvVen_mean,
	    InvVen_lower,
	    InvVen_upper,
	    deaths_mean,
	    deaths_lower,
	    deaths_upper,
	    admis_mean,
	    admis_lower,
	    admis_upper,
	    newICU_mean,
	    newICU_lower,
	    newICU_upper,
	    totdea_mean,
	    totdea_lower,
	    totdea_upper,
	    bedover_mean,
	    bedover_lower,
	    bedover_upper,
	    icuover_mean,
	    icuover_lower,
	    icuover_upper,
	    deaths_mean_smoothed,
	    deaths_lower_smoothed,
	    deaths_upper_smoothed,
	    totdea_mean_smoothed,
	    totdea_lower_smoothed,
	    totdea_upper_smoothed,
	    mobility_data_type,
	    mobility_composite,
	    total_tests_data_type,
	    total_tests,
	    confirmed_infections,
	    est_infections_mean,
	    est_infections_lower,
	    est_infections_upper,
	    REC_INS_TS,
	    REC_UPD_TS,
		Path_Update_Val) 
	values (	
	   	source.MODEL_KEY,
	    source.DATE_key,
	    source.DATE_GRANULARITY,
	    source.GEO_KEY,
	    source.GEO_GRANULARITY,
	    source.MODEL_VERSION,
	    source.location_name,
	    source.Modeled_date,
	    source.allbed_mean,
	    source.allbed_lower,
	    source.allbed_upper,
	    source.ICUbed_mean,
	    source.ICUbed_lower,
	    source.ICUbed_upper,
	    source.InvVen_mean,
	    source.InvVen_lower,
	    source.InvVen_upper,
	   	source.deaths_mean,
	    source.deaths_lower,
	    source.deaths_upper,
	    source.admis_mean,
	    source.admis_lower,
	    source.admis_upper,
	    source.newICU_mean,
	    source.newICU_lower,
	    source.newICU_upper,
	    source.totdea_mean,
	    source.totdea_lower,
	    source.totdea_upper,
	    source.bedover_mean,
	   	source.bedover_lower,
	    source.bedover_upper,
	    source.icuover_mean,
	    source.icuover_lower,
	    source.icuover_upper,
	    source.deaths_mean_smoothed,
	    source.deaths_lower_smoothed,
	    source.deaths_upper_smoothed,
	    source.totdea_mean_smoothed,
	    source.totdea_lower_smoothed,
	    source.totdea_upper_smoothed,
	    source.mobility_data_type,
	    source.mobility_composite,
	    source.total_tests_data_type,
	    source.total_tests,
	    source.confirmed_infections,
	    source.est_infections_mean,
	    source.est_infections_lower,
	    source.est_infections_upper,
	    source.REC_INS_TS,
	    source.REC_UPD_TS,
		source.Path_Update_Val);
	    
	----------------------------------------------------------- 
	SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
	----------------------------------------------------------- 

	delete from ???.FACT_Covid_Model_Data_UNPIVOT;
	insert into ???.FACT_Covid_Model_Data_UNPIVOT
	SELECT 
		MODEL_KEY,
	    DATE_KEY,
	    DATE_GRANULARITY,
	    GEO_KEY,
	    GEO_GRANULARITY,
	    MODELED_DATE,
	    MODEL_VERSION,
	    location_name,
	    mobility_data_type,
	    total_tests_data_type,
	    Metric_name,
	    Metric_value,
	    REC_INS_TS,
	    REC_UPD_TS 
		--
	    FROM ???.FACT_Covid_Model_Data 
	    UNPIVOT ((metric_value)  FOR  metric_name 
	    IN ((allbed_mean) as'allbed_mean',
			(allbed_lower) as'allbed_lower',
			(allbed_upper) as'allbed_upper',
			(ICUbed_mean) as'ICUbed_mean',
			(ICUbed_lower) as'ICUbed_lower',
			(ICUbed_upper) as'ICUbed_upper',
			(InvVen_mean) as'InvVen_mean',
			(InvVen_lower) as'InvVen_lower',
			(InvVen_upper) as'InvVen_upper',
			(deaths_mean) as'deaths_mean',
			(deaths_lower) as'deaths_lower',
			(deaths_upper) as'deaths_upper',
			(admis_mean) as'admis_mean',
			(admis_lower) as'admis_lower',
			(admis_upper) as'admis_upper',
			(newICU_mean) as'newICU_mean',
			(newICU_lower) as'newICU_lower',
			(newICU_upper) as'newICU_upper',
			(totdea_mean) as'totdea_mean',
			(totdea_lower) as'totdea_lower',
			(totdea_upper) as'totdea_upper',
			(bedover_mean) as'bedover_mean',
			(bedover_lower) as'bedover_lower',
			(bedover_upper) as'bedover_upper',
			(icuover_mean) as'icuover_mean',
			(icuover_lower) as'icuover_lower',
			(icuover_upper) as'icuover_upper',
			(deaths_mean_smoothed) as'deaths_mean_smoothed',
			(deaths_lower_smoothed) as'deaths_lower_smoothed',
			(deaths_upper_smoothed) as'deaths_upper_smoothed',
			(totdea_mean_smoothed) as'totdea_mean_smoothed',
			(totdea_lower_smoothed) as'totdea_lower_smoothed',
			(totdea_upper_smoothed) as'totdea_upper_smoothed',
			 --(mobility_data_type) as'mobility_data_type',
			 (mobility_composite) as'mobility_composite',
			--(total_tests_data_type) as'total_tests_data_type',
			 (total_tests) as'total_tests',
			(confirmed_infections) as'confirmed_infections',
			(est_infections_mean) as'est_infections_mean',
			(est_infections_lower) as'est_infections_lower',
			(est_infections_upper) as'est_infections_upper'
			) )  a
	--07/25/2020 Changes
	where a.date_key = v_Date_Key_Val;

	----------------------------------------------------------- 
	SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
	----------------------------------------------------------- 
	-- Added 07/11/20
	MERGE INTO ???.FACT_Covid_Model_Data_SUM as target
	USING  
	  (   
	   select          
	   	x.PROCESS_TYPE,     
	    x.DATE_KEY,
	    x.DATE_GRANULARITY,
	    x.GEO_KEY,
	    x.GEO_GRANULARITY,
	    x.peak_bed_day_mean,
	    x.peak_bed_day_lower,
	    x.peak_bed_day_upper,
	    x.peak_icu_bed_day_mean,
	    x.peak_icu_bed_day_lower,
	    x.peak_icu_bed_day_upper,
	    x.peak_vent_day_mean,
	    x.peak_vent_day_lower,
	    x.peak_vent_day_upper,
	    x.all_bed_capacity,
	    x.icu_bed_capacity,
	    x.all_bed_usage,
	    x.icu_bed_usage,
	    x.available_all_nbr,
	    x.available_icu_nbr,
	    x.travel_limit_start_date,
	    x.travel_limit_end_date,
	    x.stay_home_start_date,
	    x.stay_home_end_date,
	    x.educational_fac_start_date,
	    x.educational_fac_end_date,
	    x.any_gathering_restrict_start_date,
	    x.any_gathering_restrict_end_date,
	    x.any_business_start_date,
	    x.any_business_end_date,
	    x.all_non_ess_business_start_date,
	    x.all_non_ess_business_end_date,
	    x.REC_INS_TS,
	    x.REC_UPD_TS
		-- 
	from (
	 	select   
	  	a.DATE_KEY,
	    a.DATE_GRANULARITY,
	    a.GEO_KEY,
	    a.GEO_GRANULARITY,
	    a.peak_bed_day_mean,
	    a.peak_bed_day_lower,
	    a.peak_bed_day_upper,
	    a.peak_icu_bed_day_mean,
	    a.peak_icu_bed_day_lower,
	    a.peak_icu_bed_day_upper,
	    a.peak_vent_day_mean,
	    a.peak_vent_day_lower,
	    a.peak_vent_day_upper,
	    a.all_bed_capacity,
	    a.icu_bed_capacity,
	    a.all_bed_usage,
	    a.icu_bed_usage,
	    a.available_all_nbr,
	    a.available_icu_nbr,
	    a.travel_limit_start_date,
	    a.travel_limit_end_date,
	    a.stay_home_start_date,
	    a.stay_home_end_date,
	    a.educational_fac_start_date,
	    a.educational_fac_end_date,
	    a.any_gathering_restrict_start_date,
	    a.any_gathering_restrict_end_date,
	    a.any_business_start_date,
	    a.any_business_end_date,
	    a.all_non_ess_business_start_date,
	    a.all_non_ess_business_end_date,
	    coalesce(b.REC_INS_TS,current_timestamp(0)) REC_INS_TS,
	    current_timestamp REC_UPD_TS,
	    CASE WHEN b.date_KEY IS NULL THEN 'I'
	         ELSE NULL END AS PROCESS_TYPE
	    from  ( 
	 	select 
		--cast(  Path_Update_Dt  as date) date_key,
		v_Date_Key_Val as date_key,
		'Daily' date_granularity, 
	 	coalesce(l.uid,-1) geo_key,
	 	coalesce(l.geo_granularity, (select geo_granularity from ???.DIM_GEO_LOCATION_V where uid = -1) ) geo_granularity,
	    a.peak_bed_day_mean,
	    a.peak_bed_day_lower,
	    a.peak_bed_day_upper,
	    a.peak_icu_bed_day_mean,
	    a.peak_icu_bed_day_lower,
	    a.peak_icu_bed_day_upper,
	    a.peak_vent_day_mean,
	    a.peak_vent_day_lower,
	    a.peak_vent_day_upper,
	    a.all_bed_capacity,
	    a.icu_bed_capacity,
	    a.all_bed_usage,
	    a.icu_bed_usage,
	    a.available_all_nbr,
	    a.available_icu_nbr,
	    a.travel_limit_start_date,
	    a.travel_limit_end_date,
	    a.stay_home_start_date,
	    a.stay_home_end_date,
	    a.educational_fac_start_date,
	    a.educational_fac_end_date,
	    a.any_gathering_restrict_start_date,
	    a.any_gathering_restrict_end_date,
	    a.any_business_start_date,
	    a.any_business_end_date,
	    a."ALL_NON-ESS_BUSINESS_START_DATE" ALL_NON_ESS_BUSINESS_START_DATE,
	    a."ALL_NON-ESS_BUSINESS_END_DATE" ALL_NON_ESS_BUSINESS_END_DATE 
		--
	    from ???.STG_Summary_stats_all_locs a
	    left outer join ???.DIM_GEO_LOCATION_V l 
	      	on (a.location_name = l.state_name
			-- 07.29.20 Changes
	       	and l.geo_granularity = 'State' and location_id  between 500 and 599) -- handle Georgia
	       	or (a.location_name = l.country_name
	       	and l.geo_granularity = 'country')
	    --where date_key >= coalesce((select max(date_key) from ???.FACT_Covid_Model_Data_SUM),date_key)
	        ) a     
	        LEFT OUTER JOIN ???.FACT_Covid_Model_Data_SUM b
	        on a.geo_key =  b.geo_key 
			and a.date_key = b.date_key         
	        ) AS x
	  
	        WHERE x.PROCESS_TYPE IS NOT NULL 
	             
	)  as source
	--
	ON source.date_key = target.date_key
	AND source.geo_key = target.geo_key
	--
	WHEN NOT MATCHED THEN 
	insert  
	(   	
	 	DATE_KEY,
	    DATE_GRANULARITY,
	    GEO_KEY,
	    GEO_GRANULARITY,
	    peak_bed_day_mean,
	    peak_bed_day_lower,
	    peak_bed_day_upper,
	    peak_icu_bed_day_mean,
	    peak_icu_bed_day_lower,
	    peak_icu_bed_day_upper,
	    peak_vent_day_mean,
	    peak_vent_day_lower,
	    peak_vent_day_upper,
	    all_bed_capacity,
	    icu_bed_capacity,
	    all_bed_usage,
	    icu_bed_usage,
	    available_all_nbr,
	    available_icu_nbr,
	    travel_limit_start_date,
	    travel_limit_end_date,
	    stay_home_start_date,
	    stay_home_end_date,
	    educational_fac_start_date,
	    educational_fac_end_date,
	    any_gathering_restrict_start_date,
	    any_gathering_restrict_end_date,
	    any_business_start_date,
	    any_business_end_date,
	    all_non_ess_business_start_date,
	    all_non_ess_business_end_date,
	    REC_INS_TS,
	    REC_UPD_TS  ) 
	values ( 
	  	source.DATE_KEY,
	    source.DATE_GRANULARITY,
	    source.GEO_KEY,
	    source.GEO_GRANULARITY,
	    source.peak_bed_day_mean,
	    source.peak_bed_day_lower,
	    source.peak_bed_day_upper,
	    source.peak_icu_bed_day_mean,
	    source.peak_icu_bed_day_lower,
	    source.peak_icu_bed_day_upper,
	    source.peak_vent_day_mean,
	    source.peak_vent_day_lower,
	    source.peak_vent_day_upper,
	    source.all_bed_capacity,
	    source.icu_bed_capacity,
	    source.all_bed_usage,
	    source.icu_bed_usage,
	    source.available_all_nbr,
	    source.available_icu_nbr,
	    source.travel_limit_start_date,
	    source.travel_limit_end_date,
	    source.stay_home_start_date,
	    source.stay_home_end_date,
	    source.educational_fac_start_date,
	    source.educational_fac_end_date,
	    source.any_gathering_restrict_start_date,
	    source.any_gathering_restrict_end_date,
	    source.any_business_start_date,
	    source.any_business_end_date,
	    source.all_non_ess_business_start_date,
	    source.all_non_ess_business_end_date,
	    source.REC_INS_TS,
	    null  );
		--
END IF;
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;



REPLACE PROCEDURE ???.ETL_COVID19_DATAHUB_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_COVID19_DATAHUB_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : JuLY 5, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert ETL_COVID19_DATAHUB_CORE Table									 
Procedure syntax  : CALL ETL_COVID19_DATAHUB_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/05/2020      1.0         Teradata DW              	Initial
07/06/2020		2.0         Teradata DW              	Added LVL2 Code
07/06/2020		3.0			Teradata DW					severe column was not being passed anymore set to null
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_COVID19_DATAHUB';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_COVID19_DATAHUB_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

 
MERGE INTO ???.FACT_COVID19_DATAHUB as target
USING    
 ( select x.PROCESS_TYPE,      	
   	x.date_key,
    x.GEO_KEY,
    x.TEST_CNT,
    x.confirmed_CNT,
    x.recovered_CNT,
    x.deaths_CNT,
    x.HOSPITALIZED_CNT,
    x.ON_VENTILATOR_CNT,
    x.IN_ICU_CNT,
    x.SEVERE_CASE_CNT,
    x.population  ,
    x.school_closing  ,
    x.workplace_closing  ,
    x.cancel_events  ,
    x.gatherings_restrictions  ,
    x.transport_closing  ,
    x.stay_home_restrictions  ,
    x.internal_movement_restrictions  ,
    x.international_movement_restrictions  ,
    x.information_campaigns  ,
    x.testing_policy  ,
    x.contact_tracing  ,
    x.stringency_index  ,
    x.key_STR,
    x.key_numeric,
    x.key_google_mobility,
    x.key_apple_mobility,
    x.key_alpha_2, 
    x.REC_INS_TS 
   --select *  
from  
  
  (
  
 select  a.date_key,
    a.GEO_KEY,
    a.TEST_CNT,
    a.confirmed_CNT,
    a.recovered_CNT,
    a.deaths_CNT,
    a.HOSPITALIZED_CNT,
    a.ON_VENTILATOR_CNT,
    a.IN_ICU_CNT,
    a.SEVERE_CASE_CNT,
    a.population  ,
    a.school_closing  ,
    a.workplace_closing  ,
    a.cancel_events  ,
    a.gatherings_restrictions  ,
    a.transport_closing  ,
    a.stay_home_restrictions  ,
    a.internal_movement_restrictions  ,
    a.international_movement_restrictions  ,
    a.information_campaigns  ,
    a.testing_policy  ,
    a.contact_tracing  ,
    a.stringency_index  ,
    a.key_STR,
    a.key_numeric,
    a.key_google_mobility,
    a.key_apple_mobility,
    a.key_alpha_2, 
    a.REC_INS_TS ,
 
    CASE
          WHEN b.date_KEY IS NULL
                 THEN 'I'
          WHEN b.date_KEY is not null  
          and ( a.TEST_CNT <> b.TESTED_CNT or
                a.confirmed_CNT <> b.confirmed_CNT or
    			a.recovered_CNT <> b.recovered_CNT or
    			a.HOSPITALIZED_CNT <> b.HOSPITALIZED_CNT or
    			a.deaths_CNT <> b.death_CNT  or
   				a.ON_VENTILATOR_CNT <> b.ON_VENTILATOR_CNT or
    			a.IN_ICU_CNT <> b.IN_ICU_CNT or
    			a.SEVERE_CASE_CNT <> b.SEVERE_CASE_CNT )
                -- put weird logic here
                 THEN 'U'
          ELSE NULL
                     END AS PROCESS_TYPE
                     
                     --select *
    from (


SELECT 
   cast ( date_key as date) date_key,
    UID GEO_KEY,
    tests TEST_CNT,
    confirmed confirmed_CNT,
    recovered recovered_CNT,
    deaths deaths_CNT,
    hosp HOSPITALIZED_CNT,
    vent  ON_VENTILATOR_CNT,
    icu IN_ICU_CNT,
	-- 07/17/20 Changes
    0 SEVERE_CASE_CNT,
	-- End of Changes
    l3.population  ,
    school_closing  ,
    workplace_closing  ,
    cancel_events  ,
    gatherings_restrictions  ,
    transport_closing  ,
    stay_home_restrictions  ,
    internal_movement_restrictions  ,
    international_movement_restrictions  ,
    information_campaigns  ,
    testing_policy  ,
    contact_tracing  ,
    stringency_index  ,
    "key" key_STR,
    key_numeric,
    key_google_mobility,
    key_apple_mobility,
    key_alpha_2 ,
 	current_timestamp(0) REC_INS_TS
 	--select min(date_key)
from ???.STG_COVID19_Datahub_LVL3 l3
left outer join ???.DIM_GEO_LOCATION_V g
on l3.key_numeric  =  g.fips 
where g.uid is not null ) a
 
        LEFT OUTER JOIN ???.FACT_COVID19_DATAHUB_v b
           ON   a.DATE_KEY = b.DATE_KEY 
           and a.GEO_key = b.GEO_key 
       
                ) AS x
WHERE x.PROCESS_TYPE  IS NOT NULL 
         
)  as source
  

-- join on primary key is obligatory

ON  source.date_key = target.date_key
 and source.GEO_KEY = target.GEO_KEY
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	      	
   	 date_key,
    GEO_KEY,
     TESTCNT,
    confirmed_CNT,
    recovered_CNT,
     deaths_CNT,
     HOSPITALIZED_CNT,
     ON_VENTILATOR_CNT,
     IN_ICU_CNT,
     SEVERE_CASE_CNT,
     population  ,
      school_closing  ,
     workplace_closing  ,
     cancel_events  ,
      gatherings_restrictions  ,
     transport_closing  ,
     stay_home_restrictions  ,
     internal_movement_restrictions  ,
     international_movement_restrictions  ,
     information_campaigns  ,
     testing_policy  ,
     contact_tracing  ,
     stringency_index  ,
     key_STR,
     key_numeric,
     key_google_mobility,
     key_apple_mobility,
     key_alpha_2, 
     REC_INS_TS   ) 
values ( 
		   	
   	source.date_key,
    source.GEO_KEY,
    source.TEST_CNT,
    source.confirmed_CNT,
    source.recovered_CNT,
    source.deaths_CNT,
    source.HOSPITALIZED_CNT,
    source.ON_VENTILATOR_CNT,
    source.IN_ICU_CNT,
    source.SEVERE_CASE_CNT,
    source.population  ,
    source.school_closing  ,
    source.workplace_closing  ,
    source.cancel_events  ,
    source.gatherings_restrictions  ,
    source.transport_closing  ,
    source.stay_home_restrictions  ,
    source.internal_movement_restrictions  ,
    source.international_movement_restrictions  ,
    source.information_campaigns  ,
    source.testing_policy  ,
    source.contact_tracing  ,
    source.stringency_index  ,
    source.key_STR,
    source.key_numeric,
    source.key_google_mobility,
    source.key_apple_mobility,
    source.key_alpha_2, 
    source.REC_INS_TS )
     when matched then
 update 
 set   	TESTCNT = source.TEST_CNT
       	,confirmed_CNT = source.confirmed_CNT
    	,recovered_CNT = source.recovered_CNT
     	,deaths_CNT = source.deaths_CNT
     	,HOSPITALIZED_CNT = source.HOSPITALIZED_CNT
     	,ON_VENTILATOR_CNT = source.ON_VENTILATOR_CNT
     	,IN_ICU_CNT = source.IN_ICU_CNT
     	,SEVERE_CASE_CNT  = source.SEVERE_CASE_CNT
     	;
	

SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;


--LVL2 Changes
MERGE INTO ???.FACT_COVID19_DATAHUB_STATE as target
USING    
 ( select x.PROCESS_TYPE,      	
   	x.date_key,
    x.GEO_KEY,
    x.TESTED_CNT,
    x.confirmed_CNT,
    x.recovered_CNT,
    x.death_CNT,
    x.HOSPITALIZED_CNT,
    x.ON_VENTILATOR_CNT,
    x.IN_ICU_CNT,
    x.SEVERE_CASE_CNT,
    x.population  ,
    x.school_closing  ,
    x.workplace_closing  ,
    x.cancel_events  ,
    x.gatherings_restrictions  ,
    x.transport_closing  ,
    x.stay_home_restrictions  ,
    x.internal_movement_restrictions  ,
    x.international_movement_restrictions  ,
    x.information_campaigns  ,
    x.testing_policy  ,
    x.contact_tracing  ,
    x.stringency_index  ,
    x.key_STR,
    x.key_numeric,
    x.key_google_mobility,
    x.key_apple_mobility,
    x.key_alpha_2, 
    x.REC_INS_TS 
   --select *  
from  
  
  (
  
 select  a.date_key,
    a.GEO_KEY,
    a.TESTED_CNT,
    a.confirmed_CNT,
    a.recovered_CNT,
    a.death_CNT,
    a.HOSPITALIZED_CNT,
    a.ON_VENTILATOR_CNT,
    a.IN_ICU_CNT,
    a.SEVERE_CASE_CNT,
    a.population  ,
    a.school_closing  ,
    a.workplace_closing  ,
    a.cancel_events  ,
    a.gatherings_restrictions  ,
    a.transport_closing  ,
    a.stay_home_restrictions  ,
    a.internal_movement_restrictions  ,
    a.international_movement_restrictions  ,
    a.information_campaigns  ,
    a.testing_policy  ,
    a.contact_tracing  ,
    a.stringency_index  ,
    a.key_STR,
    a.key_numeric,
    a.key_google_mobility,
    a.key_apple_mobility,
    a.key_alpha_2, 
    a.REC_INS_TS ,
 
    CASE
          WHEN b.date_KEY IS NULL
                 THEN 'I'
          WHEN b.date_KEY is not null  
          and ( a.TESTED_CNT <> b.TESTED_CNT or
                a.confirmed_CNT <> b.confirmed_CNT or
    			a.recovered_CNT <> b.recovered_CNT or
    			a.HOSPITALIZED_CNT <> b.HOSPITALIZED_CNT or
    			a.death_CNT <> b.death_CNT  or
   				a.ON_VENTILATOR_CNT <> b.ON_VENTILATOR_CNT or
    			a.IN_ICU_CNT <> b.IN_ICU_CNT or
    			a.SEVERE_CASE_CNT <> b.SEVERE_CASE_CNT )
                -- put weird logic here
                 THEN 'U'
          ELSE NULL
                     END AS PROCESS_TYPE
                     
                     --select *
    from (


SELECT 
   cast ( date_key as date) date_key,
    UID GEO_KEY,
    tests TESTED_CNT,
    confirmed confirmed_CNT,
    recovered recovered_CNT,
    deaths death_CNT,
    hosp HOSPITALIZED_CNT,
    vent  ON_VENTILATOR_CNT,
    icu IN_ICU_CNT, 
	-- 07/17/20 Changes
    0 SEVERE_CASE_CNT,
	-- End of Changes 
    l2.population  ,
    school_closing  ,
    workplace_closing  ,
    cancel_events  ,
    gatherings_restrictions  ,
    transport_closing  ,
    stay_home_restrictions  ,
    internal_movement_restrictions  ,
    international_movement_restrictions  ,
    information_campaigns  ,
    testing_policy  ,
    contact_tracing  ,
    stringency_index  ,
    "key" key_STR,
    key_numeric,
    key_google_mobility,
    key_apple_mobility,
    key_alpha_2 ,
 	current_timestamp(0) REC_INS_TS
 	--select min(date_key)
from ???.STG_COVID19_Datahub_LVL2 l2 
      left outer join ???.DIM_GEO_LOCATION_V g
		on l2.administrative_area_level_2   =  g.state_name  
		where g.uid is not null 
		and g.geo_granularity = 'State') a
 
        LEFT OUTER JOIN ???.FACT_COVID19_DATAHUB_STATE_v b
           ON   a.DATE_KEY = b.DATE_KEY 
           and a.GEO_key = b.GEO_key 
       
                ) AS x
WHERE x.PROCESS_TYPE  IS NOT NULL 
         
)  as source
  

-- join on primary key is obligatory

ON  source.date_key = target.date_key
 and source.GEO_KEY = target.GEO_KEY
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	      	
   	 date_key,
    GEO_KEY,
     TESTED_CNT,
    confirmed_CNT,
    recovered_CNT,
     death_CNT,
     HOSPITALIZED_CNT,
     ON_VENTILATOR_CNT,
     IN_ICU_CNT,
     SEVERE_CASE_CNT,
     population  ,
      school_closing  ,
     workplace_closing  ,
     cancel_events  ,
      gatherings_restrictions  ,
     transport_closing  ,
     stay_home_restrictions  ,
     internal_movement_restrictions  ,
     international_movement_restrictions  ,
     information_campaigns  ,
     testing_policy  ,
     contact_tracing  ,
     stringency_index  ,
     key_STR,
     key_numeric,
     key_google_mobility,
     key_apple_mobility,
     key_alpha_2, 
     REC_INS_TS   ) 
values ( 
		   	
   	source.date_key,
    source.GEO_KEY,
    source.TESTED_CNT,
    source.confirmed_CNT,
    source.recovered_CNT,
    source.death_CNT,
    source.HOSPITALIZED_CNT,
    source.ON_VENTILATOR_CNT,
    source.IN_ICU_CNT,
    source.SEVERE_CASE_CNT,
    source.population  ,
    source.school_closing  ,
    source.workplace_closing  ,
    source.cancel_events  ,
    source.gatherings_restrictions  ,
    source.transport_closing  ,
    source.stay_home_restrictions  ,
    source.internal_movement_restrictions  ,
    source.international_movement_restrictions  ,
    source.information_campaigns  ,
    source.testing_policy  ,
    source.contact_tracing  ,
    source.stringency_index  ,
    source.key_STR,
    source.key_numeric,
    source.key_google_mobility,
    source.key_apple_mobility,
    source.key_alpha_2, 
    source.REC_INS_TS )
     when matched then
 update 
 set   	TESTED_CNT = source.TESTED_CNT
       	,confirmed_CNT = source.confirmed_CNT
    	,recovered_CNT = source.recovered_CNT
     	,death_CNT = source.death_CNT
     	,HOSPITALIZED_CNT = source.HOSPITALIZED_CNT
     	,ON_VENTILATOR_CNT = source.ON_VENTILATOR_CNT
     	,IN_ICU_CNT = source.IN_ICU_CNT
     	,SEVERE_CASE_CNT  = source.SEVERE_CASE_CNT;
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;



REPLACE PROCEDURE ???.ETL_CUST_DATA_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_CUST_DATA_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 27, 2020 			                                                                           		     
Description       : This Procecdure is used to upcert customer specific metrics into the data model									 
Procedure syntax  : CALL ETL_CUST_DATA_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/27/2020      1.0         Teradata DW              	Initial
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT '???';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_CUST_DATA_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/


 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;



REPLACE PROCEDURE ???.ETL_FUEL_PROD_CORE(OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_FUEL_PROD_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 6, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert F_IND_DASH_GOOGLE_TRENDS Table									 
Procedure syntax  : CALL ETL_FUEDL_PROD_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/06/2020      1.0         Teradata DW              	Initial
07/15/2020		2.0			Teradata DW					Adding 1000 to the metric value to get real number
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_INDICATOR_DASHBOARD_T2_p';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_FUEL_PROD_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_p as target
USING  
  ( 
 
  select          x.PROCESS_TYPE,     
    CASE
             WHEN x.PROCESS_TYPE = 'I'
         THEN y.MAX_ID + ROW_NUMBER() OVER(
         ORDER BY x.METRIC_NAME,
           x.DATE_KEY ,
           x.GEO_GRANULARITY ,
           x.DATE_KEY ,
           x.DOMAIN_NAME ,
           x.SUBDOMAIN_1_NAME,
           x.SUBDOMAIN_2_NAME,
           x.SUBDOMAIN_3_NAME 
             )

         ELSE x.INDICATOR_KEY
         END AS INDICATOR_KEY,  	
   	x.Date_key,
    x.DATE_GRANULARITY,
    x.GEO_KEY, 
    x.GEO_GRANULARITY,
    x.DOMAIN_NAME,
    x.SUBDOMAIN_1_NAME,
    x.SUBDOMAIN_2_NAME,
    x.SUBDOMAIN_3_NAME,
    x.METRIC_NAME,
    x.METRIC_VALUE,
    x.METRIC_INDEX,
    x.DATA_SOURCE_NAME,
    x.DATA_SOURCE_DESC,
    x.REC_INS_TS,
    x.REC_UPD_TS
   --select *  


from  ( 
      
     
SELECT   CASE
          WHEN b.INDICATOR_KEY IS NULL
                 THEN 'I'
          WHEN b.INDICATOR_KEY is not null  
          and (a.METRIC_VALUE <> b.METRIC_VALUE or
               a. METRIC_INDEX <> b.METRIC_INDEX) -- put weird logic here
                 THEN 'U'
          ELSE NULL
                     END AS PROCESS_TYPE,
                     b.INDICATOR_KEY,
   a.DATE_KEY,
    a.DATE_GRANULARITY,
   a.GEO_KEY,
   a.GEO_GRANULARITY,
   a.DOMAIN_NAME,
   a.SUBDOMAIN_1_NAME,
   a.SUBDOMAIN_2_NAME,
   a.SUBDOMAIN_3_NAME,
   a.METRIC_NAME,
    a.METRIC_VALUE,
    a.METRIC_INDEX,
   a.DATA_SOURCE_NAME,
    a.DATA_SOURCE_DESC,
    coalesce(b.REC_INS_TS,CURRENT_TIMESTAMP(0)) REC_INS_TS ,
    CURRENT_TIMESTAMP(0) REC_UPD_TS 
   -- SELECT min(date_key)   from ???.FACT_INDICATOR_DASHBOARD_v where   data_source_name like '%eia%' and date_key = '2003-11-07'
  
FROM (
    SELECT  cast(tmp.date_key as date) AS DATE_KEY,
     'WEEKLY' AS DATE_GRANULARITY,
   840 AS GEO_KEY,
   'COUNTRY' AS GEO_GRANULARITY,
   'Fuel Supply' AS DOMAIN_NAME,
   CASE WHEN tmp.METRIC_NAME = 'Finished Motor Gasoline 4wkavg' --'WGFUPUS2'
        THEN 'Motor Gasoline'
        WHEN tmp.METRIC_NAME = 'Jet Fuel 4wkavg' --'WKJUPUS2'
        THEN 'Jet Fuel'
        WHEN tmp.METRIC_NAME = 'Petroleum Products 4wkavg' --'WRPUPUS2'
        THEN 'All Petro-Products'
   END AS SUBDOMAIN_1_NAME,
   'Total' AS SUBDOMAIN_2_NAME,
   'Total' AS SUBDOMAIN_3_NAME,
   'US Product Supplied 4WKAVG' AS METRIC_NAME,
    tmp.METRIC_VALUE * 1000 METRIC_VALUE,
    0 METRIC_INDEX,
   'US-EIA' AS DATA_SOURCE_NAME,
   'US Energy Information Administration' AS DATA_SOURCE_DESC 
        FROM ???."STG_Fuel_Production" 
        UNPIVOT ((metric_value)  FOR  metric_name 
        IN (("4-Week Avg U.S. Product Supplied of Petroleum Products  (Thousand Barrels per Day)") AS'Petroleum Products 4wkavg', --'WRPUPUS2'
        ("4-Week Avg U.S. Product Supplied of Finished Motor Gasoline  (Thousand Barrels per Day)") AS'Finished Motor Gasoline 4wkavg', --'WGFUPUS2',
        ("4-Week Avg U.S. Product Supplied of Kerosene-Type Jet Fuel  (Thousand Barrels per Day)") AS'Jet Fuel 4wkavg',  -- 'WKJUPUS2'
        ("4-Week Avg U.S. Product Supplied of Distillate Fuel Oil  (Thousand Barrels per Day)") AS'Distillate Fuel Oil 4wkavg',
        ("4-Week Avg U.S. Product Supplied of Residual Fuel Oil  (Thousand Barrels per Day)") AS'Residual Fuel Oil 4wkavg',
        ("4-Week Avg U.S. Product Supplied of Propane and Propylene  (Thousand Barrels per Day)") AS'Propane and Propylene 4wkavg', 
        ("4-Week Avg U.S. Product Supplied of Other Oils  (Thousand Barrels per Day)") AS'Other Oils 4wkavg' )) tmp 
        where metric_name in ('Petroleum Products 4wkavg','Finished Motor Gasoline 4wkavg','Jet Fuel 4wkavg') ) a  
       


        LEFT OUTER JOIN ???.FACT_INDICATOR_DASHBOARD_v b
           ON  a.METRIC_NAME = b.METRIC_NAME
           and a.DATE_KEY = b.DATE_KEY
           and a.GEO_GRANULARITY = b.GEO_GRANULARITY
           and a.DATE_KEY = b.DATE_KEY
           and a.DOMAIN_NAME = b.DOMAIN_NAME
           and a.SUBDOMAIN_1_NAME = b.SUBDOMAIN_1_NAME
           and a.SUBDOMAIN_2_NAME = b.SUBDOMAIN_2_NAME
           and a.SUBDOMAIN_3_NAME = b.SUBDOMAIN_3_NAME
          
                ) AS x

        
          CROSS JOIN
                (SELECT
                                ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
                 FROM
                                ???.FACT_INDICATOR_DASHBOARD_v
                ) AS y  
           WHERE x.PROCESS_TYPE IS NOT NULL 
         
)  as source
  

-- join on primary key is obligatory

ON  source.INDICATOR_KEY = target.INDICATOR_KEY
and source.date_key = target.date_key
 
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	
     INDICATOR_KEY,  	
   	Date_key,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
     DATA_SOURCE_DESC,
     REC_INS_TS,
     REC_UPD_TS  ) 
values ( 
		
     source.INDICATOR_KEY,  	
   	source.Date_key,
    source.DATE_GRANULARITY,
    source.GEO_KEY, 
    source.GEO_GRANULARITY,
    source.DOMAIN_NAME,
    source.SUBDOMAIN_1_NAME,
    source.SUBDOMAIN_2_NAME,
    source.SUBDOMAIN_3_NAME,
    source.METRIC_NAME,
    source.METRIC_VALUE,
    source.METRIC_INDEX,
    source.DATA_SOURCE_NAME,
    source.DATA_SOURCE_DESC,
    source.REC_INS_TS,
    source.REC_UPD_TS   )
     when matched then
 update 
 set  METRIC_VALUE = source.METRIC_VALUE
 , METRIC_INDEX = source.METRIC_INDEX
 , REC_UPD_TS = source.REC_UPD_TS;
     

/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;




REPLACE PROCEDURE ???.ETL_GOOGLE_MOBILITY_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_GOOGLE_MOBILITY_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : June 26, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert FACT_INDICATOR_DASHBOARD_T2_p Table									 
Procedure syntax  : CALL ETL_GOOGLE_MOBILITY_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
06/26/2020      1.0         Teradata DW              	Initial
07/08/2020		2.0			Teradata DW              	Translation table to swap values from the input files
07/09/2020		3.0			Teradata DW					Code Changed to address Null value insert
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_INDICATOR_DASHBOARD_T2_P';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_GOOGLE_MOBILITY_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

delete from ???.gm_step1;
delete from ???.gm_step2;

INSERT INTO ???.gm_step1
    SELECT date_key,
        country_region_code,
        country_region,
        sub_region_1,
        sub_region_2,
        METRIC_INDEX,
        METRIC_NAME,
        
        CASE
            WHEN sub_region_1 IS NULL AND sub_region_2 IS NULL THEN 'Country'
            WHEN sub_region_1 IS NOT NULL AND sub_region_2 IS NULL THEN 'State'
            WHEN sub_region_1 IS NOT NULL AND sub_region_2 IS NOT NULL THEN 'County'
        ELSE 'n/a'
        END   geo_granularity --select distinct retail_and_recreation, grocery_and_pharmacy, parks, transit_stations, workplaces , residential
         --select *
        
        FROM ???.STG_Google_Mobility
          
        UNPIVOT ((METRIC_INDEX)  FOR  METRIC_NAME
        IN (retail_and_recreation_percent_change_from_baseline  AS 'Retail & recreation', 
        (grocery_and_pharmacy_percent_change_from_baseline) AS 'Grocery & pharmacy',
        (parks_percent_change_from_baseline) AS 'Parks',
        (transit_stations_percent_change_from_baseline) AS 'Transit Stations',
        (workplaces_percent_change_from_baseline) AS 'Workplace',
        (residential_percent_change_from_baseline) AS 'Residential')
        ) gm
        WHERE country_region  = 'United States';


INSERT INTO ???.gm_step2
    SELECT *
        FROM (
        SELECT 
            date_key,
            'Day' date_granularity,
            
            CASE
                WHEN uid IS NULL THEN
            CASE
                WHEN sub_region_1 IS NULL THEN 'country'
            ELSE 'STATE'
            END
                WHEN sub_region_2  IS NULL THEN
            CASE
                WHEN sub_region_1 IS NULL THEN  'Country'
            ELSE 'State'
            END
            ELSE 'County'
            END geo_granularity,
                uid geo_key,
                'Mobility' DOMAIN_NAME,
                'Google Mobility' SUBDOMAIN_1_NAME,
                ' ' SUBDOMAIN_2_NAME,
                ' ' SUBDOMAIN_3_NAME,
                '%Mobility_Change_Baseline for '||METRIC_NAME METRIC_NAME,
                0 METRIC_VALUE,
                CAST(METRIC_INDEX AS DECIMAL(32,6)) METRIC_INDEX,
                'Google Mobility Report' DATA_SOURCE_NAME,
                'Google Mobility Report' DATA_SOURCE_DESC,
                CURRENT_TIMESTAMP(0) REC_INS_TS,
                CURRENT_TIMESTAMP(0) REC_UPD_TS --select *
            
            FROM ???.gm_step1 gm
            JOIN  ???.DIM_GEO_LOCATION_V gl 
            ON gm.country_region_code = gl.country_code 
            AND gm.geo_granularity = gl.geo_granularity
            AND gm.geo_granularity = 'Country'
             where uid is not null
            
        UNION ALL
        SELECT 
            date_key,
            'Day' date_granularity,
            
            CASE
                WHEN uid IS NULL THEN
            CASE
                WHEN sub_region_1 IS NULL THEN 'country'
            ELSE 'STATE'
            END
                WHEN sub_region_2  IS NULL THEN
            CASE
                WHEN sub_region_1 IS NULL THEN  'Country'
            ELSE 'State'
            END
            ELSE 'County'
            END geo_granularity,
                uid geo_key,
                'Mobility' DOMAIN_NAME,
                'Google Mobility' SUBDOMAIN_1_NAME,
                ' ' SUBDOMAIN_2_NAME,
                ' ' SUBDOMAIN_3_NAME,
                '%Mobility_Change_Baseline for '||METRIC_NAME METRIC_NAME,
                0 METRIC_VALUE,
                CAST(METRIC_INDEX AS DECIMAL(32,6)) METRIC_INDEX,
                'Google Mobility Report' DATA_SOURCE_NAME,
                'Google Mobility Report' DATA_SOURCE_DESC,
                CURRENT_TIMESTAMP(0) REC_INS_TS,
                CURRENT_TIMESTAMP(0) REC_UPD_TS --select *
            
            FROM ???.gm_step1 gm
            JOIN  ???.DIM_GEO_LOCATION_V gl 
            ON gm.country_region_code = gl.country_code 
            AND gm.sub_region_1 = gl.state_name
            AND gm.geo_granularity = gl.geo_granularity
            AND gm.geo_granularity = 'State'
            where uid is not null
        UNION ALL
        SELECT 
            date_key,
            'Day' date_granularity,
            
    
            CASE
                WHEN sub_region_1 IS NULL THEN 'country'
                WHEN sub_region_2  IS NULL THEN  'State'
                else  'County'  
            END  geo_granularity,
                uid geo_key,
                'Mobility' DOMAIN_NAME,
                'Google Mobility' SUBDOMAIN_1_NAME,
                ' ' SUBDOMAIN_2_NAME,
                ' ' SUBDOMAIN_3_NAME,
                '%Mobility_Change_Baseline for '||METRIC_NAME METRIC_NAME,
                0 METRIC_VALUE,
                CAST(METRIC_INDEX AS DECIMAL(32,6)) METRIC_INDEX,
                'Google Mobility Report' DATA_SOURCE_NAME,
                'Google Mobility Report' DATA_SOURCE_DESC,
                CURRENT_TIMESTAMP(0) REC_INS_TS,
                CURRENT_TIMESTAMP(0) REC_UPD_TS --select * 
			-- Changed 070820
			--select * 
			FROM ???.gm_step1 gm
            left outer join ???.Transaltion_Table tt
            on tt.clnsng_cd = 'County'
            and tt.clnsng_src = gm.sub_region_2
			-- End of Change 070820
            JOIN  ???.DIM_GEO_LOCATION_V gl 
            ON gm.country_region_code = gl.country_code 
            AND gm.sub_region_1 = gl.state_name
            AND coalesce(tt.clnsng_trgt,gm.sub_region_2) in (  gl.county, gl.county_long )
            AND gm.geo_granularity = gl.geo_granularity          
            where  gl.geo_granularity = 'County'
            and uid is not null
            
        ) a;



MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_P as target
USING  
  ( select          x.PROCESS_TYPE,     
    CASE
             WHEN x.PROCESS_TYPE = 'I'
         THEN y.MAX_ID + ROW_NUMBER() OVER(
         ORDER BY x.METRIC_NAME,
           x.DATE_KEY ,
           x.GEO_GRANULARITY ,
           x.DATE_KEY ,
           x.DOMAIN_NAME ,
           x.SUBDOMAIN_1_NAME,
           x.SUBDOMAIN_2_NAME,
           x.SUBDOMAIN_3_NAME 
             )

         ELSE x.INDICATOR_KEY
         END AS INDICATOR_KEY,  	
   	x.Date_key,
    x.DATE_GRANULARITY,
    x.GEO_KEY, 
    x.GEO_GRANULARITY,
    x.DOMAIN_NAME,
    x.SUBDOMAIN_1_NAME,
    x.SUBDOMAIN_2_NAME,
    x.SUBDOMAIN_3_NAME,
    x.METRIC_NAME,
    x.METRIC_VALUE,
    x.METRIC_INDEX,
    x.DATA_SOURCE_NAME,
    x.DATA_SOURCE_DESC,
    x.REC_INS_TS,
    x.REC_UPD_TS
   --select *  
from ( 
SELECT 
	PROCESS_TYPE,
-- a. contains the source data
-- b. contains the target data that matches the nkey of the source data
	a.INDICATOR_KEY,  	
   	a.Date_key,
    a.DATE_GRANULARITY,
    a.GEO_KEY, 
    a.GEO_GRANULARITY,
    a.DOMAIN_NAME,
    a.SUBDOMAIN_1_NAME,
    a.SUBDOMAIN_2_NAME,
    a.SUBDOMAIN_3_NAME,
    a.METRIC_NAME,
    a.METRIC_VALUE,
    a.METRIC_INDEX,
    a.DATA_SOURCE_NAME,
    a.DATA_SOURCE_DESC,
    a.REC_INS_TS,
    a.REC_upd_TS
     
-- if b. is null that means there was no match so set the process type to insert
-- if b. is not null then compare source to target data of updatable columns to determin if there should be an update       
     
      
      FROM
  
  (
  select b.INDICATOR_KEY,
     	aa.Date_key,
    aa.DATE_GRANULARITY,
    aa.GEO_KEY, 
    aa.GEO_GRANULARITY,
    aa.DOMAIN_NAME,
    aa.SUBDOMAIN_1_NAME,
    aa.SUBDOMAIN_2_NAME,
    aa.SUBDOMAIN_3_NAME,
    aa.METRIC_NAME,
    aa.METRIC_VALUE,
    aa.METRIC_INDEX,
    aa.DATA_SOURCE_NAME,
    aa.DATA_SOURCE_DESC,
    aa.REC_INS_TS,
    aa.REC_UPD_TS,
     CASE
          WHEN b.INDICATOR_KEY IS NULL
                 THEN 'I'
          WHEN b.INDICATOR_KEY is not null  
          and (aa.METRIC_VALUE <> b.METRIC_VALUE or
               aa. METRIC_INDEX <> b.METRIC_INDEX) -- put weird logic here
                 THEN 'U'
          ELSE NULL
                     END AS PROCESS_TYPE
                     --select *
        from   ???.gm_step2 aa 
            
        LEFT OUTER JOIN  ???.FACT_INDICATOR_DASHBOARD_V  b
           ON  aa.METRIC_NAME = b.METRIC_NAME
           and aa.DATE_KEY = b.DATE_KEY
           and aa.geo_key = b.geo_key
           and aa.GEO_GRANULARITY = b.GEO_GRANULARITY 
           and aa.DOMAIN_NAME = b.DOMAIN_NAME
           and aa.SUBDOMAIN_1_NAME = b.SUBDOMAIN_1_NAME
           and aa.SUBDOMAIN_2_NAME = b.SUBDOMAIN_2_NAME
           and aa.SUBDOMAIN_3_NAME = b.SUBDOMAIN_3_NAME
           and   b.DATA_SOURCE_NAME = 'Google Mobility Report'
           )  a
                ) AS x

        
          CROSS JOIN
                (SELECT
                                ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
                 FROM
                                ???.FACT_INDICATOR_DASHBOARD_V
                ) AS y  
           WHERE x.PROCESS_TYPE is  NOT  NULL and x.PROCESS_TYPE <> 'U' 
            
)  as source
  

-- join on primary key is obligatory

ON  source.INDICATOR_KEY = target.INDICATOR_KEY
and source.geo_key = target.geo_key
and source.date_key = target.date_key
 
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	
     INDICATOR_KEY,  	
   	Date_key,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
     DATA_SOURCE_DESC,
     REC_INS_TS,
     REC_UPD_TS  ) 
values ( 
		
     source.INDICATOR_KEY,  	
   	source.Date_key,
    source.DATE_GRANULARITY,
    source.GEO_KEY, 
    source.GEO_GRANULARITY,
    source.DOMAIN_NAME,
    source.SUBDOMAIN_1_NAME,
    source.SUBDOMAIN_2_NAME,
    source.SUBDOMAIN_3_NAME,
    source.METRIC_NAME,
    source.METRIC_VALUE,
    source.METRIC_INDEX,
    source.DATA_SOURCE_NAME,
    source.DATA_SOURCE_DESC,
    source.REC_INS_TS,
    source.REC_UPD_TS )
    ;
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));

END;



REPLACE PROCEDURE ???.ETL_GOOGLE_TREND_CORE(OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_GOOGLE_TREND_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 5, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert F_IND_DASH_GOOGLE_TRENDS Table									 
Procedure syntax  : CALL ETL_GOOGLE_TREND_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/05/2020      1.0         Teradata DW              	Initial                                         					
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'F_IND_DASH_GOOGLE_TRENDS';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_GOOGLE_TREND_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

DELETE FROM ???.F_IND_DASH_GOOGLE_TRENDS;

INSERT INTO  ???.F_IND_DASH_GOOGLE_TRENDS
SELECT  DATE_KEY,
    TREND_NAME,
    GEO_KEY,
    GEO_GRANULARITY,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
    DATA_SOURCE_DESC,
    SNAPSHOT_DATE,
    REC_INS_TS,
    REC_UPD_TS from (
SELECT substring(cast("date" as varchar(30)) from 1 for 10) DATE_KEY,
    Trend_Name TREND_NAME,
    840 GEO_KEY,
    'Country' GEO_GRANULARITY,
    Metric_value METRIC_INDEX,
    'Google Trends' DATA_SOURCE_NAME,
    'Google Trends - search '|| trend_name DATA_SOURCE_DESC,
   	Keyword_list,
   	cat_cd,
   	current_timestamp(0) REC_INS_TS,
   	current_timestamp(0) REC_UPD_TS
	FROM ???.STG_Google_Search_IOT ) f
                JOIN (
            SELECT cal_week_year,
                MAX(WEEK_END_DATE) SNAPSHOT_DATE,
                MAX(CAL_WEEK_YEAR)  SNAPSHOT_WEEK,
                MIN(WEEK_START_DATE)   FIL_START_DATE_KEY,
                MAX(WEEK_END_DATE)   FIL_END_DATE_KEY 
                FROM ???.DIM_CALENDAR_V DT
                LEFT JOIN ( 
                SELECT MAX("DATE") MAX_DT
                    FROM ???.STG_Google_Search_IOT  F  
                ) MAXDT ON 1=1
                group by 1
                --WHERE CAL_DATE_KEY IN (MAX_DT-7,MAX_DT-14,MAX_DT-21,MAX_DT-28, MAX_DT-35)
            ) DT ON
            F.date_key BETWEEN DT.FIL_START_DATE_KEY AND DT.FIL_END_DATE_KEY;
     

/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;


REPLACE PROCEDURE ???.ETL_LABOR_STATS_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_LABOR_STATS_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : June 26, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert FACT_INDICATOR_DASHBOARD_T2_p Table									 
Procedure syntax  : CALL ETL_LABOR_STATS_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
06/26/2020      1.0         Teradata DW              	Initial
07/19/2020		2.0			Teradata DW              	Code was changed to include CPI data
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_INDICATOR_DASHBOARD_T2_P';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_LABOR_STATS_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_p as target
USING  
  ( select          x.PROCESS_TYPE,     
    CASE
             WHEN x.PROCESS_TYPE = 'I'
         THEN y.MAX_ID + ROW_NUMBER() OVER(
         ORDER BY x.METRIC_NAME,
           x.DATE_KEY ,
           x.GEO_GRANULARITY ,
           x.DATE_KEY ,
           x.DOMAIN_NAME ,
           x.SUBDOMAIN_1_NAME,
           x.SUBDOMAIN_2_NAME,
           x.SUBDOMAIN_3_NAME 
             )

         ELSE x.INDICATOR_KEY
         END AS INDICATOR_KEY,  	
   	x.Date_key,
    x.DATE_GRANULARITY,
    x.GEO_KEY, 
    x.GEO_GRANULARITY,
    x.DOMAIN_NAME,
    x.SUBDOMAIN_1_NAME,
    x.SUBDOMAIN_2_NAME,
    x.SUBDOMAIN_3_NAME,
    x.METRIC_NAME,
    x.METRIC_VALUE,
    x.METRIC_INDEX,
    x.DATA_SOURCE_NAME,
    x.DATA_SOURCE_DESC,
    x.REC_INS_TS,
    x.REC_UPD_TS
   --select *  
from ( 
SELECT 
	PROCESS_TYPE,
-- a. contains the source data
-- b. contains the target data that matches the nkey of the source data
	a.INDICATOR_KEY,  	
   	a.Date_key,
    a.DATE_GRANULARITY,
    a.GEO_KEY, 
    a.GEO_GRANULARITY,
    a.DOMAIN_NAME,
    a.SUBDOMAIN_1_NAME,
    a.SUBDOMAIN_2_NAME,
    a.SUBDOMAIN_3_NAME,
    a.METRIC_NAME,
    a.METRIC_VALUE,
    a.METRIC_INDEX,
    a.DATA_SOURCE_NAME,
    a.DATA_SOURCE_DESC,
    a.REC_INS_TS,
    a.REC_upd_TS
     
-- if b. is null that means there was no match so set the process type to insert
-- if b. is not null then compare source to target data of updatable columns to determin if there should be an update       
     
      
      FROM
  
  (
  select b.INDICATOR_KEY,
     	aa.Date_key,
    aa.DATE_GRANULARITY,
    aa.GEO_KEY, 
    aa.GEO_GRANULARITY,
    aa.DOMAIN_NAME,
    aa.SUBDOMAIN_1_NAME,
    aa.SUBDOMAIN_2_NAME,
    aa.SUBDOMAIN_3_NAME,
    aa.METRIC_NAME,
    aa.METRIC_VALUE,
    aa.METRIC_INDEX,
    aa.DATA_SOURCE_NAME,
    aa.DATA_SOURCE_DESC,
    aa.REC_INS_TS,
    aa.REC_UPD_TS,
     CASE
          WHEN b.INDICATOR_KEY IS NULL
                 THEN 'I'
          WHEN b.INDICATOR_KEY is not null  
          and (aa.METRIC_VALUE <> b.METRIC_VALUE or
               aa. METRIC_INDEX <> b.METRIC_INDEX) -- put weird logic here
                 THEN 'U'
          ELSE NULL
                     END AS PROCESS_TYPE
        from  ( 
      
  SELECT   'Monthly' date_granularity,
           840 GEO_KEY, 
    'Country' GEO_GRANULARITY,
    cast(year_key||'-'||substring(period_key from 2 for 2)||'-01' as date) date_key,
    CASE 
    	WHEN series_id = 'LNS13000000'  
    		THEN cast(metric_Val as decimal(32,6)) * 1000    
    	else  cast(metric_Val as decimal(32,6))  end METRIC_VALUE ,
    0   METRIC_index,
    'BLS' DATA_SOURCE_NAME, 
    'BLS - CPI - Unemployment level/rate' DATA_SOURCE_DESC,
    
    CASE
    	WHEN series_id = 'CUSR0000SA0' THEN 'Consumer Price Index'
        WHEN series_id = 'LNS13000000' THEN 'Unemployment Level'
        WHEN series_id = 'LNS14000000' THEN 'Unemployment Rate'
    END DOMAIN_NAME,
        'Total' SUBDOMAIN_1_NAME,
        'Total' SUBDOMAIN_2_NAME,
        'Total' SUBDOMAIN_3_NAME,
        
    CASE
        WHEN series_id = 'CUSR0000SA0' THEN 'CPI'
        WHEN series_id = 'LNS13000000' THEN 'Unemployment Level'
        WHEN series_id = 'LNS14000000' THEN 'Unemployment Rate'
    END METRIC_NAME,
        CURRENT_TIMESTAMP(0) REC_INS_TS,
        CURRENT_TIMESTAMP(0) REC_UPD_TS --select * 
    
    FROM  /* creates separte tables due to a bug in the BLS.GOV API */
		(select * from  ???.STG_Labor_Stats_CUSR0000SA0
		union all
		select * from ???.STG_Labor_Stats_LNS13000000
		union all
		select * from ???.STG_Labor_Stats_LNS14000000 ) all_bls
        

        
        
        ) aa     
        LEFT OUTER JOIN ???.FACT_INDICATOR_DASHBOARD_v b
           ON  aa.METRIC_NAME = b.METRIC_NAME
           and aa.DATE_KEY = b.DATE_KEY
           and aa.GEO_GRANULARITY = b.GEO_GRANULARITY
           and aa.DATE_KEY = b.DATE_KEY
           and aa.DOMAIN_NAME = b.DOMAIN_NAME
           and aa.SUBDOMAIN_1_NAME = b.SUBDOMAIN_1_NAME
           and aa.SUBDOMAIN_2_NAME = b.SUBDOMAIN_2_NAME
           and aa.SUBDOMAIN_3_NAME = b.SUBDOMAIN_3_NAME
           )  a
                ) AS x

        
          CROSS JOIN
                (SELECT
                                ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
                            
                 FROM
                                ???.FACT_INDICATOR_DASHBOARD_v  
                ) AS y  
           WHERE x.PROCESS_TYPE IS NOT NULL 
            
)  as source
  

-- join on primary key is obligatory

ON  source.INDICATOR_KEY = target.INDICATOR_KEY
and source.date_key = target.date_key
 
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	
     INDICATOR_KEY,  	
   	Date_key,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
     DATA_SOURCE_DESC,
     REC_INS_TS,
     REC_UPD_TS  ) 
values ( 
		
     source.INDICATOR_KEY,  	
   	source.Date_key,
    source.DATE_GRANULARITY,
    source.GEO_KEY, 
    source.GEO_GRANULARITY,
    source.DOMAIN_NAME,
    source.SUBDOMAIN_1_NAME,
    source.SUBDOMAIN_2_NAME,
    source.SUBDOMAIN_3_NAME,
    source.METRIC_NAME,
    source.METRIC_VALUE,
    source.METRIC_INDEX,
    source.DATA_SOURCE_NAME,
    source.DATA_SOURCE_DESC,
    source.REC_INS_TS,
    source.REC_UPD_TS   )
     when matched then
 update 
 set  METRIC_VALUE = source.METRIC_VALUE
 , METRIC_INDEX = source.METRIC_INDEX
 , REC_UPD_TS = source.REC_UPD_TS ;
	
	
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;


REPLACE PROCEDURE ???.ETL_LOOKUP_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_LOOKUP_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 16, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert ETL_LOOKUP_CORE Table									 
Procedure syntax  : CALL ETL_LOOKUP_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/16/2020      1.0         Teradata DW              	Initial
07/29/2020		2.0			Teradata DW              	Modififed per additional COUNTY_FIPS addition
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_LOOKUP_TABLES';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_LOOKUP_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/
DELETE FROM ???.DIM_ZIPCODE_COUNTY_MSA_LKUP;
INSERT INTO ???.DIM_ZIPCODE_COUNTY_MSA_LKUP
SELECT 
   ZIPCODE, 
   STATE_NAME,
   COUNTY_FIPS,
   COUNTY_NAME,
   MSA_NAME
FROM
   ???.DIM_ZIP_COUNTY_MSA_MAP_RAW T
 WHERE ZIPCODE NOT IN (
'51603',
'54120',
'57256',
'59260',
'62985',
'98068')
QUALIFY RANK() OVER (PARTITION BY ZIPCODE ORDER BY COUNTY_TOT_RATIO DESC) = 1;


INSERT INTO ???.DIM_ZIPCODE_COUNTY_MSA_LKUP
SELECT 
   ZIPCODE, 
   STATE_NAME,
   COUNTY_FIPS,
   COUNTY_NAME,
   MSA_NAME
FROM
   ???.DIM_ZIP_COUNTY_MSA_MAP_RAW T
 WHERE ZIPCODE  IN (
'51603',
'54120',
'57256',
'59260',
'62985',
'98068')
QUALIFY RANK() OVER (PARTITION BY ZIPCODE ORDER BY COUNTY_TOT_RATIO DESC, MSA_NAME DESC, CBSA_NAME DESC, COUNTY_FIPS) = 1;


UPDATE ???.DIM_ZIPCODE_COUNTY_MSA_LKUP
FROM
(
 SELECT 
    L.COUNTY_FIPS, 
    L.COUNTY_NAME AS COUNTY_NAME_ORIG, 
    L.STATE_NAME, 
    G.FIPS, 
    G.COUNTY AS COUNTY_NAME_STD, 
    G.STATE_CODE
 FROM 
    ???.DIM_ZIPCODE_COUNTY_MSA_LKUP_V L
    LEFT JOIN ???.DIM_GEO_LOCATION_V G ON
      L.COUNTY_FIPS = G.FIPS AND 
      L.STATE_NAME = G.STATE_NAME AND
      G.GEO_GRANULARITY = 'COUNTY' AND
      G.COUNTRY_NAME = 'United States'
 WHERE
      TRIM(L.COUNTY_NAME) <> TRIM(G.COUNTY)
 GROUP BY 1,2,3,4,5,6
) SRC
SET 
 COUNTY_NAME = SRC.COUNTY_NAME_STD
WHERE
 DIM_ZIPCODE_COUNTY_MSA_LKUP.COUNTY_FIPS = SRC.COUNTY_FIPS AND
 DIM_ZIPCODE_COUNTY_MSA_LKUP.STATE_NAME  = SRC.STATE_NAME;
	
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;


REPLACE PROCEDURE ???.ETL_POST_LOAD_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_POST_LOAD_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 9, 2020 			                                                                           		     
Description       : This Procecdure is used to insert any post load activities such as stats collection or etc,									 
Procedure syntax  : CALL ETL_POST_LOAD_CORE (v_MsgTxt,v_RowCnt,v_ResultSet);      

1 - Represnts Failure
Null - Represnts Success
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/09/2020      1.0         Teradata DW              	Initial                                         					
*/
/*****************************************************************************************************/

BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'NA';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_POST_LOAD_CORE';
DECLARE sqlstr VARCHAR(10000);
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

COLLECT STATISTICS ON ???.DIM_People_location COLUMN (Zipcode);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_COUNTY_7MAVG COLUMN (COUNTY,STATE_NAME);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_COUNTY_7MAVG COLUMN (COUNTY,STATE_NAME);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT COLUMN (SNAPSHOT_DATE,CURR_PREV_FLAG,GEO_KEY);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (DATA_SOURCE_NAME,DATE_KEY);
COLLECT STATISTICS ON ???.DIM_Site_addresses COLUMN (Zipcode);
COLLECT STATISTICS ON ???.DIM_ZIPCODE_COUNTY_MSA_LKUP COLUMN (ZIPCODE);
COLLECT STATISTICS ON ???.STG_covid19_stats COLUMN (date_key);
COLLECT STATISTICS ON ???.DIM_GEO_LOCATION_T COLUMN (Country_code,GEO_GRANULARITY);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_COUNTY_7MAVG COLUMN (DATE_KEY,GEO_KEY);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT COLUMN (COUNTRY_NAME);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (DATE_KEY,GEO_KEY,DATA_SOURCE_NAME);
COLLECT STATISTICS ON ???.DIM_Site_addresses COLUMN (Client_name);
COLLECT STATISTICS ON ???.DIM_ZIPCODE_COUNTY_MSA_LKUP COLUMN (COUNTY_NAME,STATE_NAME);
COLLECT STATISTICS ON ???.DIM_GEO_LOCATION_T COLUMN (County,STATE_NAME,STATE_CODE,COUNTRY_NAME,Population);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_COUNTY_7MAVG COLUMN (DATE_KEY);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT COLUMN (DATE_KEY);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (DATE_KEY,GEO_KEY);
COLLECT STATISTICS ON ???.DIM_Site_addresses COLUMN (Country_cd);
COLLECT STATISTICS ON ???.DIM_ZIPCODE_COUNTY_MSA_LKUP COLUMN (MSA_NAME);
COLLECT STATISTICS ON ???.DIM_GEO_LOCATION_T COLUMN (UID);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_COUNTY_7MAVG COLUMN (PARTITION);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT COLUMN (SNAPSHOT_DATE);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (PARTITION);
COLLECT STATISTICS ON ???.DIM_ZIPCODE_COUNTY_MSA_LKUP COLUMN (STATE_NAME,COUNTY_NAME,MSA_NAME);
COLLECT STATISTICS ON ???.DIM_GEO_LOCATION_T COLUMN (COUNTRY_NAME);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT COLUMN (SNAPSHOT_DATE,GEO_KEY,DATE_KEY);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (DATE_KEY);
COLLECT STATISTICS ON ???.DIM_GEO_LOCATION_T COLUMN (GEO_GRANULARITY);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT COLUMN (GEO_KEY,DATE_KEY);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (GEO_KEY);
COLLECT STATISTICS ON ???.DIM_GEO_LOCATION_T COLUMN (County,STATE_NAME);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT COLUMN (PARTITION);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (DATA_SOURCE_NAME);
COLLECT STATISTICS ON ???.DIM_GEO_LOCATION_T COLUMN (County);
COLLECT STATISTICS ON ???.F_IND_DASH_NYT_COVID19_GEO_7MAVG_WEEKLY_SNPSHT COLUMN (GEO_KEY);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (DATA_SOURCE_NAME,GEO_KEY);
COLLECT STATISTICS ON ???.FACT_INDICATOR_DASHBOARD_T2_P COLUMN (DOMAIN_NAME);

/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;

/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));

	
END;


REPLACE PROCEDURE ???.ETL_TSA_TRAVEL_CORE (OUT v_MsgTxt VARCHAR(100), OUT v_RowCnt INT,OUT v_ResultSet INT)
/*********************************************************************************************************/
/* 
Procedure Name    : ETL_TSA_TRAVEL_CORE                                              		
Developed By      : Teradata Team                                                                            			  
Created           : July 19, 2020 			                                                                           		     
Description       : This Procecdure is used to Upcert  Table									 
Procedure syntax  : CALL ETL_TSA_TRAVEL_CORE (v_MsgTxt,v_RowCnt,v_ResultSet) ;      

1 - Represnts Failure
Null - Represnts Success   FACT_INDICATOR_DASHBOARD_T2_P
                                                                                                                                  
Date           	Ver#		Modified By(Name)       	Version Comments                   
-----------   	-------     -------------------------	----------------------------                       
07/19/2020      1.0         Teradata DW              	Initial
07/22/2020		2.0			Teradata DW              	Changed the date format due to error from Disney
*/
/*****************************************************************************************************/
SQL SECURITY INVOKER
BEGIN

 /* Local Variable Declaration */ 
DECLARE v_CoreTable VARCHAR(100) DEFAULT 'FACT_INDICATOR_DASHBOARD_T2_P';
DECLARE v_RecordsAffected INTEGER DEFAULT 0;
DECLARE v_ProcName VARCHAR(100) DEFAULT 'ETL_TSA_TRAVEL_CORE';
DECLARE v_Message VARCHAR(200);

/* Exception Handling when when SQL Exception occurs */
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
	GET DIAGNOSTICS EXCEPTION 1
	v_Message = MESSAGE_TEXT;
	INSERT INTO ???.ETL_Proc_Error_Logs (Sql_Code,Logged_Time,Sql_State,Error_Text,Procedure_Name)
	VALUES(:SQLCODE,CURRENT_TIMESTAMP(0),:SQLSTATE,v_Message,v_ProcName);
	--
	SET v_ResultSet=1;
	SET v_MsgTxt='Error,refer to ETL_Proc_Error_Logs';
END;

/******************************************************************/
--Put Your Transformation Logic Here
/******************************************************************/

--travel tsa
MERGE INTO ???.FACT_INDICATOR_DASHBOARD_T2_P as target
USING  
  ( select          x.PROCESS_TYPE,     
    CASE
             WHEN x.PROCESS_TYPE = 'I'
         THEN y.MAX_ID + ROW_NUMBER() OVER(
         ORDER BY x.METRIC_NAME,
           x.DATE_KEY ,
           x.GEO_GRANULARITY ,
           x.DATE_KEY ,
           x.DOMAIN_NAME ,
           x.SUBDOMAIN_1_NAME,
           x.SUBDOMAIN_2_NAME,
           x.SUBDOMAIN_3_NAME 
             )

         ELSE x.INDICATOR_KEY
         END AS INDICATOR_KEY,  	
   	x.Date_key,
    x.DATE_GRANULARITY,
    x.GEO_KEY, 
    x.GEO_GRANULARITY,
    x.DOMAIN_NAME,
    x.SUBDOMAIN_1_NAME,
    x.SUBDOMAIN_2_NAME,
    x.SUBDOMAIN_3_NAME,
    x.METRIC_NAME,
    x.METRIC_VALUE,
    x.METRIC_INDEX,
    x.DATA_SOURCE_NAME,
    x.DATA_SOURCE_DESC,
    x.REC_INS_TS,
    x.REC_UPD_TS
   --select *  
from ( 
SELECT 
	PROCESS_TYPE,
-- a. contains the source data
-- b. contains the target data that matches the nkey of the source data
	a.INDICATOR_KEY,  	
   	a.Date_key,
    a.DATE_GRANULARITY,
    a.GEO_KEY, 
    a.GEO_GRANULARITY,
    a.DOMAIN_NAME,
    a.SUBDOMAIN_1_NAME,
    a.SUBDOMAIN_2_NAME,
    a.SUBDOMAIN_3_NAME,
    a.METRIC_NAME,
    a.METRIC_VALUE,
    a.METRIC_INDEX,
    a.DATA_SOURCE_NAME,
    a.DATA_SOURCE_DESC,
    a.REC_INS_TS,
    a.REC_upd_TS
     
-- if b. is null that means there was no match so set the process type to insert
-- if b. is not null then compare source to target data of updatable columns to determin if there should be an update       
     
      
      FROM
  
  (
  select b.INDICATOR_KEY,
     	aa.Date_key,
    aa.DATE_GRANULARITY,
    aa.GEO_KEY, 
    aa.GEO_GRANULARITY,
    aa.DOMAIN_NAME,
    aa.SUBDOMAIN_1_NAME,
    aa.SUBDOMAIN_2_NAME,
    aa.SUBDOMAIN_3_NAME,
    aa.METRIC_NAME,
    aa.METRIC_VALUE,
    aa.METRIC_INDEX,
    aa.DATA_SOURCE_NAME,
    aa.DATA_SOURCE_DESC,
    aa.REC_INS_TS,
    aa.REC_UPD_TS,
     CASE
          WHEN b.INDICATOR_KEY IS NULL
                 THEN 'I'
          WHEN b.INDICATOR_KEY is not null  
          and (aa.METRIC_VALUE <> b.METRIC_VALUE or
               aa. METRIC_INDEX <> b.METRIC_INDEX) -- put weird logic here
                 THEN 'U'
          ELSE NULL
                     END AS PROCESS_TYPE
        from  ( 
        
        
      select
	  	-- 07/22/20 Change
	    cast(TO_DATE((lpad(STRTOK(travel_date,'/',1),2,'0')||'/'||lpad(STRTOK(travel_date,'/',1),2,'0')|| '/'||STRTOK(travel_date,'/',3)),'MM/DD/YYYY') as date) DATE_KEY,
 		'Daily' DATE_GRANULARITY , 
    	'840' GEO_KEY  ,
    	 'Country' GEO_GRANULARITY,  
    	 'TSA Travel'  DOMAIN_NAME ,  
    	 ' ' SUBDOMAIN_1_NAME	,
	 	' ' SUBDOMAIN_2_NAME	,
	 	' ' SUBDOMAIN_3_NAME	,
	    'Traffic Volume' METRIC_NAME,
	   	TravelThroughPut   METRIC_VALUE	 ,
	     0  METRIC_index ,
	  	'TSA Travel' DATA_SOURCE_NAME ,
	 	'TSA Travel' DATA_SOURCE_DESC ,
	 	current_timestamp(0) REC_INS_TS, 	 
	 	current_timestamp(0) REC_UPD_TS
        FROM  ???.STG_TSA_TRAVEL
        where travel_date is not null 
        --
        union all 
        select
		-- 07/22/20 Change
   		cast(TO_DATE((lpad(STRTOK(travel_date,'/',1),2,'0')||'/'||lpad(STRTOK(travel_date,'/',1),2,'0')|| '/'||STRTOK(travel_date,'/',3)),'MM/DD/YYYY') as date) -365 DATE_KEY,
 		'Daily' DATE_GRANULARITY , 
    	'840' GEO_KEY  ,
     	'Country' GEO_GRANULARITY,  
      	'TSA Travel'  DOMAIN_NAME ,  
     	' ' SUBDOMAIN_1_NAME	,
	 	' ' SUBDOMAIN_2_NAME	,
	 	' ' SUBDOMAIN_3_NAME	,
	    'Traffic Volume' METRIC_NAME,
	    TravelThroughPutLastYear   METRIC_VALUE	 ,
	    0  METRIC_index ,
	  	'TSA Travel' DATA_SOURCE_NAME ,
	 	'TSA Travel' DATA_SOURCE_DESC ,
	 	current_timestamp(0) REC_INS_TS, 	 
	 	current_timestamp(0) REC_UPD_TS 
        FROM  ???.STG_TSA_TRAVEL 
        where travel_date is not null 
        ) aa     
        LEFT OUTER JOIN ???.FACT_INDICATOR_DASHBOARD_v b
           ON  aa.METRIC_NAME = b.METRIC_NAME
           and aa.DATE_KEY = b.DATE_KEY
           and aa.GEO_GRANULARITY = b.GEO_GRANULARITY
           and aa.geo_key = b.geo_key
           and aa.DATE_KEY = b.DATE_KEY
           and aa.DOMAIN_NAME = b.DOMAIN_NAME
           and aa.SUBDOMAIN_1_NAME = b.SUBDOMAIN_1_NAME
           and aa.SUBDOMAIN_2_NAME = b.SUBDOMAIN_2_NAME
           and aa.SUBDOMAIN_3_NAME = b.SUBDOMAIN_3_NAME
           )  a
                ) AS x

        
          CROSS JOIN
                (SELECT
                                ZEROIFNULL(MAX(INDICATOR_KEY)) AS MAX_ID
                 FROM
                                ???.FACT_INDICATOR_DASHBOARD_v
                ) AS y  
           WHERE x.PROCESS_TYPE IS NOT NULL 
            
)  as source
  

-- join on primary key is obligatory

ON  source.INDICATOR_KEY = target.INDICATOR_KEY
and source.date_key = target.date_key
 
--WHEN MATCHED THEN UPDATE
--SET product_status  = source.product_status
WHEN NOT MATCHED THEN 
insert  
(   	
     INDICATOR_KEY,  	
   	Date_key,
    DATE_GRANULARITY,
    GEO_KEY, 
    GEO_GRANULARITY,
    DOMAIN_NAME,
    SUBDOMAIN_1_NAME,
    SUBDOMAIN_2_NAME,
    SUBDOMAIN_3_NAME,
    METRIC_NAME,
    METRIC_VALUE,
    METRIC_INDEX,
    DATA_SOURCE_NAME,
     DATA_SOURCE_DESC,
     REC_INS_TS,
     REC_UPD_TS  ) 
values ( 
		
     source.INDICATOR_KEY,  	
   	source.Date_key,
    source.DATE_GRANULARITY,
    source.GEO_KEY, 
    source.GEO_GRANULARITY,
    source.DOMAIN_NAME,
    source.SUBDOMAIN_1_NAME,
    source.SUBDOMAIN_2_NAME,
    source.SUBDOMAIN_3_NAME,
    source.METRIC_NAME,
    source.METRIC_VALUE,
    source.METRIC_INDEX,
    source.DATA_SOURCE_NAME,
    source.DATA_SOURCE_DESC,
    source.REC_INS_TS,
    source.REC_UPD_TS   );
 
/******************************************************************/
--End of Transformation Logic
/******************************************************************/	


/*Getting Number of rows affected*/
SET v_RecordsAffected = v_RecordsAffected + ACTIVITY_COUNT;
SET v_RowCnt = v_RecordsAffected;


/*Insert Into Core Job Log*/
INSERT INTO ???.ETL_Indicator_Proj_Audit VALUES (v_ProcName,'Core',v_CoreTable,v_RecordsAffected,current_timestamp(0));
	
END;